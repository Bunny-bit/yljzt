/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Web
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import url from 'url';
const portableFetch = fetch;
import { Configuration } from './configuration';

//const BASE_PATH = "http://220.165.143.73:666".replace(/\/+$/, "");
const BASE_PATH =
	location.host.indexOf('localhost') >= 0 || location.host.indexOf('127.0.0.1') >= 0
		? `${location.protocol}//${location.host}/api`.replace(/\/+$/, '')
		: `${location.protocol}//${location.host}`.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AboutOutput
 */
export interface AboutOutput {
    /**
     * 
     * @type {string}
     * @memberof AboutOutput
     */
    aboutUrl?: string;
}

/**
 * 
 * @export
 * @interface AcceptFriendshipRequestInput
 */
export interface AcceptFriendshipRequestInput {
    /**
     * 
     * @type {number}
     * @memberof AcceptFriendshipRequestInput
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof AcceptFriendshipRequestInput
     */
    tenantId?: number;
}

/**
 * 
 * @export
 * @interface AjaxResponse
 */
export interface AjaxResponse {
    /**
     * 
     * @type {any}
     * @memberof AjaxResponse
     */
    result?: any;
    /**
     * 
     * @type {string}
     * @memberof AjaxResponse
     */
    targetUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AjaxResponse
     */
    success?: boolean;
    /**
     * 
     * @type {ErrorInfo}
     * @memberof AjaxResponse
     */
    error?: ErrorInfo;
    /**
     * 
     * @type {boolean}
     * @memberof AjaxResponse
     */
    unAuthorizedRequest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AjaxResponse
     */
    abp?: boolean;
}

/**
 * 
 * @export
 * @interface AppEditionDto
 */
export interface AppEditionDto {
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    creationTime?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    appType?: string;
    /**
     * 
     * @type {number}
     * @memberof AppEditionDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    itunesUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    aboutUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    installationPackage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AppEditionDto
     */
    isMandatoryUpdate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppEditionDto
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppEditionDto
     */
    describe?: string;
}

/**
 * 
 * @export
 * @interface ArrayDtoInt32
 */
export interface ArrayDtoInt32 {
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof ArrayDtoInt32
     */
    value: Array<number>;
}

/**
 * 
 * @export
 * @interface ArrayDtoInt64
 */
export interface ArrayDtoInt64 {
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof ArrayDtoInt64
     */
    value: Array<number>;
}

/**
 * 
 * @export
 * @interface AuditLogListDto
 */
export interface AuditLogListDto {
    /**
     * 
     * @type {number}
     * @memberof AuditLogListDto
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    userName?: string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogListDto
     */
    impersonatorTenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof AuditLogListDto
     */
    impersonatorUserId?: number;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    methodName?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    parameters?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    executionTime?: string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogListDto
     */
    executionDuration?: number;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    clientIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    clientName?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    browserInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    exception?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogListDto
     */
    customData?: string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogListDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface BatchActiveUserInput
 */
export interface BatchActiveUserInput {
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof BatchActiveUserInput
     */
    ids?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof BatchActiveUserInput
     */
    isActive?: boolean;
}

/**
 * 
 * @export
 * @interface BindingThirdPartyInput
 */
export interface BindingThirdPartyInput {
    /**
     * 
     * @type {string}
     * @memberof BindingThirdPartyInput
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof BindingThirdPartyInput
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BindingThirdPartyInput
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface BlockUserInput
 */
export interface BlockUserInput {
    /**
     * 
     * @type {number}
     * @memberof BlockUserInput
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockUserInput
     */
    tenantId?: number;
}

/**
 * 
 * @export
 * @interface ChangePasswordInput
 */
export interface ChangePasswordInput {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordInput
     */
    currentPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordInput
     */
    newPassword: string;
}

/**
 * 
 * @export
 * @interface ChangeUiThemeInput
 */
export interface ChangeUiThemeInput {
    /**
     * 
     * @type {string}
     * @memberof ChangeUiThemeInput
     */
    theme: string;
}

/**
 * 
 * @export
 * @interface ChangeUserPasswordInput
 */
export interface ChangeUserPasswordInput {
    /**
     * 
     * @type {number}
     * @memberof ChangeUserPasswordInput
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof ChangeUserPasswordInput
     */
    newPassword: string;
}

/**
 * 
 * @export
 * @interface ChatMessageDto
 */
export interface ChatMessageDto {
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    tenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    targetUserId?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    targetTenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    side?: ChatMessageDto.SideEnum;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    readState?: ChatMessageDto.ReadStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ChatMessageDto
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof ChatMessageDto
     */
    creationTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof ChatMessageDto
     */
    id?: number;
}

/**
 * @export
 * @namespace ChatMessageDto
 */
export namespace ChatMessageDto {
    /**
     * @export
     * @enum {string}
     */
    export enum SideEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReadStateEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface CheckCodeInput
 */
export interface CheckCodeInput {
    /**
     * 
     * @type {number}
     * @memberof CheckCodeInput
     */
    point: number;
    /**
     * 
     * @type {string}
     * @memberof CheckCodeInput
     */
    dateList?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckCodeInput
     */
    timespan?: string;
}

/**
 * 
 * @export
 * @interface CheckCodeOutput
 */
export interface CheckCodeOutput {
    /**
     * 
     * @type {boolean}
     * @memberof CheckCodeOutput
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckCodeOutput
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface CheckUpdateOutput
 */
export interface CheckUpdateOutput {
    /**
     * 
     * @type {string}
     * @memberof CheckUpdateOutput
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckUpdateOutput
     */
    downloadtUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckUpdateOutput
     */
    itunesUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CheckUpdateOutput
     */
    isMandatoryUpdate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckUpdateOutput
     */
    describe?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckUpdateOutput
     */
    aboutUrl?: string;
}

/**
 * 
 * @export
 * @interface ClearAllCacheModel
 */
export interface ClearAllCacheModel {
    /**
     * 
     * @type {string}
     * @memberof ClearAllCacheModel
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface ClearCacheModel
 */
export interface ClearCacheModel {
    /**
     * 
     * @type {string}
     * @memberof ClearCacheModel
     */
    password?: string;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof ClearCacheModel
     */
    caches?: Array<string>;
}

/**
 * 
 * @export
 * @interface ClientSettingDto
 */
export interface ClientSettingDto {
    /**
     * 
     * @type {boolean}
     * @memberof ClientSettingDto
     */
    allowSelfRegistration?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSettingDto
     */
    weixinOpenIsEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSettingDto
     */
    alipayIsEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSettingDto
     */
    qqIsEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientSettingDto
     */
    weiboIsEnabled?: boolean;
}

/**
 * 
 * @export
 * @interface ConfirmEmailCodeInput
 */
export interface ConfirmEmailCodeInput {
    /**
     * 
     * @type {string}
     * @memberof ConfirmEmailCodeInput
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmEmailCodeInput
     */
    email: string;
}

/**
 * 
 * @export
 * @interface CreateAndroidAppEditionInput
 */
export interface CreateAndroidAppEditionInput {
    /**
     * 
     * @type {string}
     * @memberof CreateAndroidAppEditionInput
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndroidAppEditionInput
     */
    aboutUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndroidAppEditionInput
     */
    installationPackage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAndroidAppEditionInput
     */
    isMandatoryUpdate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAndroidAppEditionInput
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAndroidAppEditionInput
     */
    describe?: string;
}

/**
 * 
 * @export
 * @interface CreateAppStartPageDto
 */
export interface CreateAppStartPageDto {
    /**
     * 
     * @type {number}
     * @memberof CreateAppStartPageDto
     */
    platform?: CreateAppStartPageDto.PlatformEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateAppStartPageDto
     */
    widthPx?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAppStartPageDto
     */
    highPx?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateAppStartPageDto
     */
    url?: string;
}

/**
 * @export
 * @namespace CreateAppStartPageDto
 */
export namespace CreateAppStartPageDto {
    /**
     * @export
     * @enum {string}
     */
    export enum PlatformEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface CreateDemoDto
 */
export interface CreateDemoDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDemoDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDemoDto
     */
    longText?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDemoDto
     */
    group?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateDemoDto
     */
    isActivate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateDemoDto
     */
    sort?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateDemoDto
     */
    weight?: number;
    /**
     * 
     * @type {Date}
     * @memberof CreateDemoDto
     */
    publishTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreateDemoDto
     */
    avatar?: string;
    /**
     * 
     * @type {Location}
     * @memberof CreateDemoDto
     */
    location?: Location;
}

/**
 * 
 * @export
 * @interface CreateFriendshipRequestByUserNameInput
 */
export interface CreateFriendshipRequestByUserNameInput {
    /**
     * 
     * @type {string}
     * @memberof CreateFriendshipRequestByUserNameInput
     */
    tenancyName: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFriendshipRequestByUserNameInput
     */
    userName?: string;
}

/**
 * 
 * @export
 * @interface CreateFriendshipRequestInput
 */
export interface CreateFriendshipRequestInput {
    /**
     * 
     * @type {number}
     * @memberof CreateFriendshipRequestInput
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateFriendshipRequestInput
     */
    tenantId?: number;
}

/**
 * 
 * @export
 * @interface CreateIOSAppEditionInput
 */
export interface CreateIOSAppEditionInput {
    /**
     * 
     * @type {string}
     * @memberof CreateIOSAppEditionInput
     */
    itunesUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIOSAppEditionInput
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIOSAppEditionInput
     */
    aboutUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIOSAppEditionInput
     */
    installationPackage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateIOSAppEditionInput
     */
    isMandatoryUpdate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateIOSAppEditionInput
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateIOSAppEditionInput
     */
    describe?: string;
}

/**
 * 创建菜单参数
 * @export
 * @interface CreateMenuInput
 */
export interface CreateMenuInput {
    /**
     * 上级菜单ID
     * @type {number}
     * @memberof CreateMenuInput
     */
    parentId?: number;
    /**
     * 显示名称
     * @type {string}
     * @memberof CreateMenuInput
     */
    displayName?: string;
    /**
     * 图标名称
     * @type {string}
     * @memberof CreateMenuInput
     */
    icon?: string;
    /**
     * 菜单顺序
     * @type {number}
     * @memberof CreateMenuInput
     */
    order?: number;
    /**
     * 菜单是否可见
     * @type {boolean}
     * @memberof CreateMenuInput
     */
    isVisible?: boolean;
    /**
     * 权限限制
     * @type {string}
     * @memberof CreateMenuInput
     */
    requiredPermissionName?: string;
    /**
     * 目标链接
     * @type {string}
     * @memberof CreateMenuInput
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface CreateOrUpdateRoleInput
 */
export interface CreateOrUpdateRoleInput {
    /**
     * 角色信息
     * @type {RoleEditDto}
     * @memberof CreateOrUpdateRoleInput
     */
    role: RoleEditDto;
    /**
     * 拥有的权限
     * @type {Array&lt;string&gt;}
     * @memberof CreateOrUpdateRoleInput
     */
    grantedPermissionNames: Array<string>;
}

/**
 * 创建或编辑用户 参数
 * @export
 * @interface CreateOrUpdateUserInput
 */
export interface CreateOrUpdateUserInput {
    /**
     * 用户信息
     * @type {UserEditDto}
     * @memberof CreateOrUpdateUserInput
     */
    user: UserEditDto;
    /**
     * 角色
     * @type {Array&lt;string&gt;}
     * @memberof CreateOrUpdateUserInput
     */
    assignedRoleNames: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateUserInput
     */
    sendActivationMessage?: boolean;
    /**
     * 是否需要发送激活邮件
     * @type {boolean}
     * @memberof CreateOrUpdateUserInput
     */
    sendActivationEmail?: boolean;
    /**
     * 是否使用随机密码
     * @type {boolean}
     * @memberof CreateOrUpdateUserInput
     */
    setRandomPassword?: boolean;
    /**
     * 组织机构信息
     * @type {Array&lt;number&gt;}
     * @memberof CreateOrUpdateUserInput
     */
    organizations?: Array<number>;
}

/**
 * 创建组织机构参数
 * @export
 * @interface CreateOrganizationUnitInput
 */
export interface CreateOrganizationUnitInput {
    /**
     * 上级机构ID
     * @type {number}
     * @memberof CreateOrganizationUnitInput
     */
    parentId?: number;
    /**
     * 机构名称
     * @type {string}
     * @memberof CreateOrganizationUnitInput
     */
    displayName: string;
}

/**
 * 
 * @export
 * @interface CurrentUserProfileEditDto
 */
export interface CurrentUserProfileEditDto {
    /**
     * 
     * @type {string}
     * @memberof CurrentUserProfileEditDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserProfileEditDto
     */
    surname: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserProfileEditDto
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserProfileEditDto
     */
    emailAddress: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserProfileEditDto
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentUserProfileEditDto
     */
    timezone?: string;
}

/**
 * 删除菜单参数
 * @export
 * @interface DeleteMenuInput
 */
export interface DeleteMenuInput {
    /**
     * 
     * @type {number}
     * @memberof DeleteMenuInput
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface DragVerificationDto
 */
export interface DragVerificationDto {
    /**
     * 
     * @type {number}
     * @memberof DragVerificationDto
     */
    y?: number;
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof DragVerificationDto
     */
    array?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof DragVerificationDto
     */
    imgX?: number;
    /**
     * 
     * @type {number}
     * @memberof DragVerificationDto
     */
    imgY?: number;
    /**
     * 
     * @type {string}
     * @memberof DragVerificationDto
     */
    small?: string;
    /**
     * 
     * @type {string}
     * @memberof DragVerificationDto
     */
    normal?: string;
}

/**
 * 
 * @export
 * @interface EntityDto
 */
export interface EntityDto {
    /**
     * 
     * @type {number}
     * @memberof EntityDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface EntityDtoGuid
 */
export interface EntityDtoGuid {
    /**
     * 
     * @type {string}
     * @memberof EntityDtoGuid
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface EntityDtoInt32
 */
export interface EntityDtoInt32 {
    /**
     * 
     * @type {number}
     * @memberof EntityDtoInt32
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface EntityDtoInt64
 */
export interface EntityDtoInt64 {
    /**
     * 
     * @type {number}
     * @memberof EntityDtoInt64
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
    /**
     * 
     * @type {number}
     * @memberof ErrorInfo
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorInfo
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorInfo
     */
    details?: string;
    /**
     * 
     * @type {Array&lt;ValidationErrorInfo&gt;}
     * @memberof ErrorInfo
     */
    validationErrors?: Array<ValidationErrorInfo>;
}

/**
 * 
 * @export
 * @interface FileDto
 */
export interface FileDto {
    /**
     * 
     * @type {string}
     * @memberof FileDto
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDto
     */
    fileType?: string;
    /**
     * 
     * @type {string}
     * @memberof FileDto
     */
    fileToken?: string;
}

/**
 * 
 * @export
 * @interface FirendshipUserDto
 */
export interface FirendshipUserDto {
    /**
     * 
     * @type {number}
     * @memberof FirendshipUserDto
     */
    tenantId?: number;
    /**
     * 
     * @type {string}
     * @memberof FirendshipUserDto
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof FirendshipUserDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FirendshipUserDto
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof FirendshipUserDto
     */
    emailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof FirendshipUserDto
     */
    creationTime?: string;
    /**
     * 
     * @type {number}
     * @memberof FirendshipUserDto
     */
    id?: number;
}

/**
 * 权限
 * @export
 * @interface FlatPermissionDto
 */
export interface FlatPermissionDto {
    /**
     * 上级名称
     * @type {string}
     * @memberof FlatPermissionDto
     */
    parentName?: string;
    /**
     * 名称
     * @type {string}
     * @memberof FlatPermissionDto
     */
    name?: string;
    /**
     * 显示名称
     * @type {string}
     * @memberof FlatPermissionDto
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof FlatPermissionDto
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlatPermissionDto
     */
    isGrantedByDefault?: boolean;
}

/**
 * 
 * @export
 * @interface FlatPermissionWithLevelDto
 */
export interface FlatPermissionWithLevelDto {
    /**
     * 
     * @type {number}
     * @memberof FlatPermissionWithLevelDto
     */
    level?: number;
    /**
     * 上级名称
     * @type {string}
     * @memberof FlatPermissionWithLevelDto
     */
    parentName?: string;
    /**
     * 名称
     * @type {string}
     * @memberof FlatPermissionWithLevelDto
     */
    name?: string;
    /**
     * 显示名称
     * @type {string}
     * @memberof FlatPermissionWithLevelDto
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof FlatPermissionWithLevelDto
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlatPermissionWithLevelDto
     */
    isGrantedByDefault?: boolean;
}

/**
 * 
 * @export
 * @interface FriendDto
 */
export interface FriendDto {
    /**
     * 
     * @type {number}
     * @memberof FriendDto
     */
    friendUserId?: number;
    /**
     * 
     * @type {number}
     * @memberof FriendDto
     */
    friendTenantId?: number;
    /**
     * 
     * @type {string}
     * @memberof FriendDto
     */
    friendUserName?: string;
    /**
     * 
     * @type {string}
     * @memberof FriendDto
     */
    friendTenancyName?: string;
    /**
     * 
     * @type {string}
     * @memberof FriendDto
     */
    friendProfilePictureId?: string;
    /**
     * 
     * @type {number}
     * @memberof FriendDto
     */
    unreadMessageCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FriendDto
     */
    isOnline?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FriendDto
     */
    state?: FriendDto.StateEnum;
}

/**
 * @export
 * @namespace FriendDto
 */
export namespace FriendDto {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface GeetestCheckInput
 */
export interface GeetestCheckInput {
    /**
     * 
     * @type {string}
     * @memberof GeetestCheckInput
     */
    challenge: string;
    /**
     * 
     * @type {string}
     * @memberof GeetestCheckInput
     */
    validate: string;
    /**
     * 
     * @type {string}
     * @memberof GeetestCheckInput
     */
    seccode: string;
}

/**
 * 
 * @export
 * @interface GetAboutAndCheckUpdateOutput
 */
export interface GetAboutAndCheckUpdateOutput {
    /**
     * 
     * @type {AboutOutput}
     * @memberof GetAboutAndCheckUpdateOutput
     */
    about?: AboutOutput;
    /**
     * 
     * @type {CheckUpdateOutput}
     * @memberof GetAboutAndCheckUpdateOutput
     */
    checkUpdate?: CheckUpdateOutput;
}

/**
 * 
 * @export
 * @interface GetAppEditionsInput
 */
export interface GetAppEditionsInput {
    /**
     * 
     * @type {number}
     * @memberof GetAppEditionsInput
     */
    appSearchType?: GetAppEditionsInput.AppSearchTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAppEditionsInput
     */
    filter?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAppEditionsInput
     */
    sorting?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAppEditionsInput
     */
    maxResultCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAppEditionsInput
     */
    skipCount?: number;
}

/**
 * @export
 * @namespace GetAppEditionsInput
 */
export namespace GetAppEditionsInput {
    /**
     * @export
     * @enum {string}
     */
    export enum AppSearchTypeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface GetAppStartPageDto
 */
export interface GetAppStartPageDto {
    /**
     * 
     * @type {Date}
     * @memberof GetAppStartPageDto
     */
    creationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetAppStartPageDto
     */
    creationTime?: string;
    /**
     * 
     * @type {Date}
     * @memberof GetAppStartPageDto
     */
    lastModificationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetAppStartPageDto
     */
    lastModificationTime?: string;
    /**
     * 
     * @type {Date}
     * @memberof GetAppStartPageDto
     */
    updateTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAppStartPageDto
     */
    fileName?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageDto
     */
    platform?: GetAppStartPageDto.PlatformEnum;
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageDto
     */
    widthPx?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageDto
     */
    highPx?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAppStartPageDto
     */
    url?: string;
}

/**
 * @export
 * @namespace GetAppStartPageDto
 */
export namespace GetAppStartPageDto {
    /**
     * @export
     * @enum {string}
     */
    export enum PlatformEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface GetAppStartPageInput
 */
export interface GetAppStartPageInput {
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageInput
     */
    platform?: GetAppStartPageInput.PlatformEnum;
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageInput
     */
    widthPx?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAppStartPageInput
     */
    highPx?: number;
}

/**
 * @export
 * @namespace GetAppStartPageInput
 */
export namespace GetAppStartPageInput {
    /**
     * @export
     * @enum {string}
     */
    export enum PlatformEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface GetAuditLogsInput
 */
export interface GetAuditLogsInput {
    /**
     * 
     * @type {Date}
     * @memberof GetAuditLogsInput
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof GetAuditLogsInput
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetAuditLogsInput
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuditLogsInput
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuditLogsInput
     */
    methodName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAuditLogsInput
     */
    browserInfo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetAuditLogsInput
     */
    hasException?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetAuditLogsInput
     */
    minExecutionDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAuditLogsInput
     */
    maxExecutionDuration?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAuditLogsInput
     */
    sorting?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAuditLogsInput
     */
    skipCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAuditLogsInput
     */
    maxResultCount?: number;
}

/**
 * 
 * @export
 * @interface GetCurrentLoginInformationsOutput
 */
export interface GetCurrentLoginInformationsOutput {
    /**
     * 
     * @type {UserLoginInfoDto}
     * @memberof GetCurrentLoginInformationsOutput
     */
    user?: UserLoginInfoDto;
    /**
     * 
     * @type {TenantLoginInfoDto}
     * @memberof GetCurrentLoginInformationsOutput
     */
    tenant?: TenantLoginInfoDto;
}

/**
 * 
 * @export
 * @interface GetFileSettingDemoDto
 */
export interface GetFileSettingDemoDto {
    /**
     * 
     * @type {Date}
     * @memberof GetFileSettingDemoDto
     */
    lastModificationTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof GetFileSettingDemoDto
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GetFileSettingDemoDto
     */
    fileSize?: number;
    /**
     * 
     * @type {string}
     * @memberof GetFileSettingDemoDto
     */
    fileExtension?: string;
}

/**
 * 
 * @export
 * @interface GetListAppStartPageDto
 */
export interface GetListAppStartPageDto {
    /**
     * 
     * @type {Date}
     * @memberof GetListAppStartPageDto
     */
    creationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetListAppStartPageDto
     */
    creationTime?: string;
    /**
     * 
     * @type {Date}
     * @memberof GetListAppStartPageDto
     */
    lastModificationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetListAppStartPageDto
     */
    lastModificationTime?: string;
    /**
     * 
     * @type {Date}
     * @memberof GetListAppStartPageDto
     */
    updateTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof GetListAppStartPageDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GetListAppStartPageDto
     */
    fileName?: string;
    /**
     * 
     * @type {number}
     * @memberof GetListAppStartPageDto
     */
    platform?: GetListAppStartPageDto.PlatformEnum;
    /**
     * 
     * @type {number}
     * @memberof GetListAppStartPageDto
     */
    widthPx?: number;
    /**
     * 
     * @type {number}
     * @memberof GetListAppStartPageDto
     */
    highPx?: number;
    /**
     * 
     * @type {string}
     * @memberof GetListAppStartPageDto
     */
    url?: string;
}

/**
 * @export
 * @namespace GetListAppStartPageDto
 */
export namespace GetListAppStartPageDto {
    /**
     * @export
     * @enum {string}
     */
    export enum PlatformEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface GetListDemoDto
 */
export interface GetListDemoDto {
    /**
     * 
     * @type {Date}
     * @memberof GetListDemoDto
     */
    creationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetListDemoDto
     */
    creationTime?: string;
    /**
     * 
     * @type {Date}
     * @memberof GetListDemoDto
     */
    lastModificationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetListDemoDto
     */
    lastModificationTime?: string;
    /**
     * 
     * @type {number}
     * @memberof GetListDemoDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GetListDemoDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListDemoDto
     */
    longText?: string;
    /**
     * 
     * @type {string}
     * @memberof GetListDemoDto
     */
    group?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetListDemoDto
     */
    isActivate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetListDemoDto
     */
    sort?: number;
    /**
     * 
     * @type {number}
     * @memberof GetListDemoDto
     */
    weight?: number;
    /**
     * 
     * @type {Date}
     * @memberof GetListDemoDto
     */
    publishTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetListDemoDto
     */
    avatar?: string;
    /**
     * 
     * @type {Location}
     * @memberof GetListDemoDto
     */
    location?: Location;
}

/**
 * 
 * @export
 * @interface GetNotificationSettingsOutput
 */
export interface GetNotificationSettingsOutput {
    /**
     * 
     * @type {boolean}
     * @memberof GetNotificationSettingsOutput
     */
    receiveNotifications?: boolean;
    /**
     * 
     * @type {Array&lt;NotificationSubscriptionWithDisplayNameDto&gt;}
     * @memberof GetNotificationSettingsOutput
     */
    notifications?: Array<NotificationSubscriptionWithDisplayNameDto>;
}

/**
 * 
 * @export
 * @interface GetNotificationsOutput
 */
export interface GetNotificationsOutput {
    /**
     * 
     * @type {number}
     * @memberof GetNotificationsOutput
     */
    unreadCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetNotificationsOutput
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;UserNotification&gt;}
     * @memberof GetNotificationsOutput
     */
    items?: Array<UserNotification>;
}

/**
 * 获取可加入某组织机构的人员请求
 * @export
 * @interface GetOrganizationUnitJoinableUserListInput
 */
export interface GetOrganizationUnitJoinableUserListInput {
    /**
     * 组织机构Id
     * @type {number}
     * @memberof GetOrganizationUnitJoinableUserListInput
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationUnitJoinableUserListInput
     */
    filter?: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationUnitJoinableUserListInput
     */
    skipCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationUnitJoinableUserListInput
     */
    maxResultCount?: number;
}

/**
 * 获取组织下人员信息请求
 * @export
 * @interface GetOrganizationUnitUsersInput
 */
export interface GetOrganizationUnitUsersInput {
    /**
     * 机构ID
     * @type {number}
     * @memberof GetOrganizationUnitUsersInput
     */
    id?: number;
    /**
     * 是否递归查找下级机构数据
     * @type {boolean}
     * @memberof GetOrganizationUnitUsersInput
     */
    isRecursiveSearch?: boolean;
    /**
     * 用户名称过滤条件
     * @type {string}
     * @memberof GetOrganizationUnitUsersInput
     */
    nameFilter?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationUnitUsersInput
     */
    sorting?: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationUnitUsersInput
     */
    maxResultCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationUnitUsersInput
     */
    skipCount?: number;
}

/**
 * 
 * @export
 * @interface GetPasswordComplexitySettingOutput
 */
export interface GetPasswordComplexitySettingOutput {
    /**
     * 
     * @type {PasswordComplexitySetting}
     * @memberof GetPasswordComplexitySettingOutput
     */
    setting?: PasswordComplexitySetting;
}

/**
 * 编辑角色 需要的信息
 * @export
 * @interface GetRoleForEditOutput
 */
export interface GetRoleForEditOutput {
    /**
     * 角色
     * @type {RoleEditDto}
     * @memberof GetRoleForEditOutput
     */
    role?: RoleEditDto;
    /**
     * 权限列表
     * @type {Array&lt;FlatPermissionDto&gt;}
     * @memberof GetRoleForEditOutput
     */
    permissions?: Array<FlatPermissionDto>;
    /**
     * 该角色拥有的权限
     * @type {Array&lt;string&gt;}
     * @memberof GetRoleForEditOutput
     */
    grantedPermissionNames?: Array<string>;
}

/**
 * 
 * @export
 * @interface GetRolesInput
 */
export interface GetRolesInput {
    /**
     * 权限过滤
     * @type {string}
     * @memberof GetRolesInput
     */
    permission?: string;
    /**
     * 
     * @type {string}
     * @memberof GetRolesInput
     */
    filter?: string;
}

/**
 * 
 * @export
 * @interface GetUserChatFriendsWithSettingsOutput
 */
export interface GetUserChatFriendsWithSettingsOutput {
    /**
     * 
     * @type {Date}
     * @memberof GetUserChatFriendsWithSettingsOutput
     */
    serverTime?: Date;
    /**
     * 
     * @type {Array&lt;FriendDto&gt;}
     * @memberof GetUserChatFriendsWithSettingsOutput
     */
    friends?: Array<FriendDto>;
    /**
     * 
     * @type {Array&lt;FriendDto&gt;}
     * @memberof GetUserChatFriendsWithSettingsOutput
     */
    blockes?: Array<FriendDto>;
}

/**
 * 
 * @export
 * @interface GetUserChatMessagesInput
 */
export interface GetUserChatMessagesInput {
    /**
     * 
     * @type {number}
     * @memberof GetUserChatMessagesInput
     */
    tenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof GetUserChatMessagesInput
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof GetUserChatMessagesInput
     */
    minMessageId?: number;
}

/**
 * 
 * @export
 * @interface GetUserForEditOutput
 */
export interface GetUserForEditOutput {
    /**
     * 
     * @type {string}
     * @memberof GetUserForEditOutput
     */
    profilePictureId?: string;
    /**
     * 
     * @type {UserEditDto}
     * @memberof GetUserForEditOutput
     */
    user?: UserEditDto;
    /**
     * 
     * @type {Array&lt;UserRoleDto&gt;}
     * @memberof GetUserForEditOutput
     */
    roles?: Array<UserRoleDto>;
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof GetUserForEditOutput
     */
    organizationIds?: Array<number>;
}

/**
 * 
 * @export
 * @interface GetUserLoginsInput
 */
export interface GetUserLoginsInput {
    /**
     * 
     * @type {Date}
     * @memberof GetUserLoginsInput
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof GetUserLoginsInput
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof GetUserLoginsInput
     */
    sorting?: string;
    /**
     * 
     * @type {number}
     * @memberof GetUserLoginsInput
     */
    skipCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetUserLoginsInput
     */
    maxResultCount?: number;
}

/**
 * 
 * @export
 * @interface GetUserNotificationsInput
 */
export interface GetUserNotificationsInput {
    /**
     * 
     * @type {number}
     * @memberof GetUserNotificationsInput
     */
    state?: GetUserNotificationsInput.StateEnum;
    /**
     * 
     * @type {number}
     * @memberof GetUserNotificationsInput
     */
    maxResultCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetUserNotificationsInput
     */
    skipCount?: number;
}

/**
 * @export
 * @namespace GetUserNotificationsInput
 */
export namespace GetUserNotificationsInput {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface GetUserPermissionsForEditOutput
 */
export interface GetUserPermissionsForEditOutput {
    /**
     * 
     * @type {Array&lt;PermissionDto&gt;}
     * @memberof GetUserPermissionsForEditOutput
     */
    permissions?: Array<PermissionDto>;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof GetUserPermissionsForEditOutput
     */
    grantedPermissionNames?: Array<string>;
}

/**
 * 获取用户列表参数
 * @export
 * @interface GetUsersInput
 */
export interface GetUsersInput {
    /**
     * 模糊匹配  Name、Surname、UserName、EmailAddress
     * @type {string}
     * @memberof GetUsersInput
     */
    filter?: string;
    /**
     * 拥有此权限的用户
     * @type {string}
     * @memberof GetUsersInput
     */
    permission?: string;
    /**
     * 拥有此角色的用户
     * @type {number}
     * @memberof GetUsersInput
     */
    role?: number;
    /**
     * 
     * @type {string}
     * @memberof GetUsersInput
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUsersInput
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUsersInput
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof GetUsersInput
     */
    sorting?: string;
    /**
     * 
     * @type {number}
     * @memberof GetUsersInput
     */
    maxResultCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetUsersInput
     */
    skipCount?: number;
}

/**
 * 
 * @export
 * @interface IsTenantAvailableInput
 */
export interface IsTenantAvailableInput {
    /**
     * 
     * @type {string}
     * @memberof IsTenantAvailableInput
     */
    tenancyName: string;
}

/**
 * 
 * @export
 * @interface IsTenantAvailableOutput
 */
export interface IsTenantAvailableOutput {
    /**
     * 
     * @type {number}
     * @memberof IsTenantAvailableOutput
     */
    state?: IsTenantAvailableOutput.StateEnum;
    /**
     * 
     * @type {number}
     * @memberof IsTenantAvailableOutput
     */
    tenantId?: number;
}

/**
 * @export
 * @namespace IsTenantAvailableOutput
 */
export namespace IsTenantAvailableOutput {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3
    }
}

/**
 * 
 * @export
 * @interface IsUpatedInput
 */
export interface IsUpatedInput {
    /**
     * 
     * @type {Date}
     * @memberof IsUpatedInput
     */
    updateTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof IsUpatedInput
     */
    platform?: IsUpatedInput.PlatformEnum;
    /**
     * 
     * @type {number}
     * @memberof IsUpatedInput
     */
    widthPx?: number;
    /**
     * 
     * @type {number}
     * @memberof IsUpatedInput
     */
    highPx?: number;
}

/**
 * @export
 * @namespace IsUpatedInput
 */
export namespace IsUpatedInput {
    /**
     * @export
     * @enum {string}
     */
    export enum PlatformEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface ListResultDtoChatMessageDto
 */
export interface ListResultDtoChatMessageDto {
    /**
     * 
     * @type {Array&lt;ChatMessageDto&gt;}
     * @memberof ListResultDtoChatMessageDto
     */
    items?: Array<ChatMessageDto>;
}

/**
 * 
 * @export
 * @interface ListResultDtoFlatPermissionWithLevelDto
 */
export interface ListResultDtoFlatPermissionWithLevelDto {
    /**
     * 
     * @type {Array&lt;FlatPermissionWithLevelDto&gt;}
     * @memberof ListResultDtoFlatPermissionWithLevelDto
     */
    items?: Array<FlatPermissionWithLevelDto>;
}

/**
 * 
 * @export
 * @interface ListResultDtoOrganizationUnitDto
 */
export interface ListResultDtoOrganizationUnitDto {
    /**
     * 
     * @type {Array&lt;OrganizationUnitDto&gt;}
     * @memberof ListResultDtoOrganizationUnitDto
     */
    items?: Array<OrganizationUnitDto>;
}

/**
 * 
 * @export
 * @interface ListResultDtoRoleDto
 */
export interface ListResultDtoRoleDto {
    /**
     * 
     * @type {Array&lt;RoleDto&gt;}
     * @memberof ListResultDtoRoleDto
     */
    items?: Array<RoleDto>;
}

/**
 * 
 * @export
 * @interface ListResultDtoRoleListDto
 */
export interface ListResultDtoRoleListDto {
    /**
     * 
     * @type {Array&lt;RoleListDto&gt;}
     * @memberof ListResultDtoRoleListDto
     */
    items?: Array<RoleListDto>;
}

/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    longitude?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    latitude?: string;
}

/**
 * 
 * @export
 * @interface LoginForSmsCode
 */
export interface LoginForSmsCode {
    /**
     * 
     * @type {string}
     * @memberof LoginForSmsCode
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginForSmsCode
     */
    code?: string;
}

/**
 * 
 * @export
 * @interface LoginModel
 */
export interface LoginModel {
    /**
     * 
     * @type {boolean}
     * @memberof LoginModel
     */
    rememberMe?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoginModel
     */
    usernameOrEmailAddress: string;
    /**
     * 
     * @type {string}
     * @memberof LoginModel
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof LoginModel
     */
    captcha?: string;
}

/**
 * 
 * @export
 * @interface MarkAllUnreadMessagesOfUserAsReadInput
 */
export interface MarkAllUnreadMessagesOfUserAsReadInput {
    /**
     * 
     * @type {number}
     * @memberof MarkAllUnreadMessagesOfUserAsReadInput
     */
    tenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof MarkAllUnreadMessagesOfUserAsReadInput
     */
    userId?: number;
}

/**
 * 菜单
 * @export
 * @interface MenuDto
 */
export interface MenuDto {
    /**
     * 上级菜单
     * @type {number}
     * @memberof MenuDto
     */
    parentId?: number;
    /**
     * 
     * @type {string}
     * @memberof MenuDto
     */
    name?: string;
    /**
     * 显示名称
     * @type {string}
     * @memberof MenuDto
     */
    displayName?: string;
    /**
     * 图标名称
     * @type {string}
     * @memberof MenuDto
     */
    icon?: string;
    /**
     * 是否叶子节点
     * @type {boolean}
     * @memberof MenuDto
     */
    isLeaf?: boolean;
    /**
     * 菜单顺序
     * @type {number}
     * @memberof MenuDto
     */
    order?: number;
    /**
     * 菜单是否可用
     * @type {boolean}
     * @memberof MenuDto
     */
    isEnabled?: boolean;
    /**
     * 菜单是否可见
     * @type {boolean}
     * @memberof MenuDto
     */
    isVisible?: boolean;
    /**
     * 权限限制
     * @type {string}
     * @memberof MenuDto
     */
    requiredPermissionName?: string;
    /**
     * 是否需要登录才可查看菜单
     * @type {boolean}
     * @memberof MenuDto
     */
    requiresAuthentication?: boolean;
    /**
     * 打开方式 \"_blank\", \"_self\", \"_parent\", \"_top\"或者iframe名字
     * @type {string}
     * @memberof MenuDto
     */
    target?: string;
    /**
     * 目标链接
     * @type {string}
     * @memberof MenuDto
     */
    url?: string;
    /**
     * 是否系统菜单
     * @type {boolean}
     * @memberof MenuDto
     */
    isSystem?: boolean;
    /**
     * 
     * @type {Array&lt;MenuDto&gt;}
     * @memberof MenuDto
     */
    items?: Array<MenuDto>;
    /**
     * 
     * @type {number}
     * @memberof MenuDto
     */
    id?: number;
}

/**
 * 移动菜单项
 * @export
 * @interface MoveMenuInput
 */
export interface MoveMenuInput {
    /**
     * 菜单ID
     * @type {number}
     * @memberof MoveMenuInput
     */
    id?: number;
    /**
     * 新的上级菜单
     * @type {number}
     * @memberof MoveMenuInput
     */
    newParentId?: number;
    /**
     * 菜单新顺序
     * @type {number}
     * @memberof MoveMenuInput
     */
    newOrder?: number;
}

/**
 * 移动组织机构请求
 * @export
 * @interface MoveOrganizationUnitInput
 */
export interface MoveOrganizationUnitInput {
    /**
     * 组织机构ID
     * @type {number}
     * @memberof MoveOrganizationUnitInput
     */
    id?: number;
    /**
     * 新的上级组织机构ID
     * @type {number}
     * @memberof MoveOrganizationUnitInput
     */
    newParentId?: number;
}

/**
 * 
 * @export
 * @interface NotificationData
 */
export interface NotificationData {
    /**
     * 
     * @type {string}
     * @memberof NotificationData
     */
    type?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NotificationData
     */
    properties?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface NotificationSubscriptionDto
 */
export interface NotificationSubscriptionDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscriptionDto
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSubscriptionDto
     */
    isSubscribed?: boolean;
}

/**
 * 
 * @export
 * @interface NotificationSubscriptionWithDisplayNameDto
 */
export interface NotificationSubscriptionWithDisplayNameDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscriptionWithDisplayNameDto
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscriptionWithDisplayNameDto
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationSubscriptionWithDisplayNameDto
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationSubscriptionWithDisplayNameDto
     */
    isSubscribed?: boolean;
}

/**
 * 
 * @export
 * @interface NullableIdDto
 */
export interface NullableIdDto {
    /**
     * 
     * @type {number}
     * @memberof NullableIdDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface NullableIdDtoInt64
 */
export interface NullableIdDtoInt64 {
    /**
     * 
     * @type {number}
     * @memberof NullableIdDtoInt64
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface OAuthSettingDto
 */
export interface OAuthSettingDto {
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    siteUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthSettingDto
     */
    weixinOpenIsEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    weixinOpenAppID?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    weixinOpenAppSecret?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthSettingDto
     */
    alipayIsEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    alipayAppID?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    alipayAppPrivateKey?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    alipayAlipayPublicKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthSettingDto
     */
    qqIsEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    qqAppID?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    qqAppKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthSettingDto
     */
    weiboIsEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    weiboAppID?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthSettingDto
     */
    weibAppSecret?: string;
}

/**
 * 组织机构信息
 * @export
 * @interface OrganizationUnitDto
 */
export interface OrganizationUnitDto {
    /**
     * 上级机构ID
     * @type {number}
     * @memberof OrganizationUnitDto
     */
    parentId?: number;
    /**
     * 机构Code
     * @type {string}
     * @memberof OrganizationUnitDto
     */
    code?: string;
    /**
     * 机构名称
     * @type {string}
     * @memberof OrganizationUnitDto
     */
    displayName?: string;
    /**
     * 组织机构人员数量
     * @type {number}
     * @memberof OrganizationUnitDto
     */
    memberCount?: number;
    /**
     * 下级组织机构
     * @type {Array&lt;OrganizationUnitDto&gt;}
     * @memberof OrganizationUnitDto
     */
    children?: Array<OrganizationUnitDto>;
    /**
     * 
     * @type {Date}
     * @memberof OrganizationUnitDto
     */
    lastModificationTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUnitDto
     */
    lastModifierUserId?: number;
    /**
     * 
     * @type {Date}
     * @memberof OrganizationUnitDto
     */
    creationTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUnitDto
     */
    creatorUserId?: number;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUnitDto
     */
    id?: number;
}

/**
 * 归属于组织单元的人员信息
 * @export
 * @interface OrganizationUnitUserDto
 */
export interface OrganizationUnitUserDto {
    /**
     * 
     * @type {number}
     * @memberof OrganizationUnitUserDto
     */
    id?: number;
    /**
     * 用户名
     * @type {string}
     * @memberof OrganizationUnitUserDto
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUnitUserDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUnitUserDto
     */
    phoneNumber?: string;
    /**
     * 用户创建时间
     * @type {string}
     * @memberof OrganizationUnitUserDto
     */
    creationTime?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUnitUserDto
     */
    emailAddress?: string;
}

/**
 * 用户信息
 * @export
 * @interface OrganizationUnitUserListDto
 */
export interface OrganizationUnitUserListDto {
    /**
     * 用户名称
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    name?: string;
    /**
     * 显示名称
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    surname?: string;
    /**
     * 用户账号
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    userName?: string;
    /**
     * 邮件地址
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    emailAddress?: string;
    /**
     * 头像ID
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    profilePictureId?: string;
    /**
     * 创建时间
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    addedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUnitUserListDto
     */
    phoneNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof OrganizationUnitUserListDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface PagedAndFilteredInputDto
 */
export interface PagedAndFilteredInputDto {
    /**
     * 
     * @type {number}
     * @memberof PagedAndFilteredInputDto
     */
    maxResultCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedAndFilteredInputDto
     */
    skipCount?: number;
    /**
     * 
     * @type {string}
     * @memberof PagedAndFilteredInputDto
     */
    filter?: string;
}

/**
 * 
 * @export
 * @interface PagedResultDtoAppEditionDto
 */
export interface PagedResultDtoAppEditionDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoAppEditionDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;AppEditionDto&gt;}
     * @memberof PagedResultDtoAppEditionDto
     */
    items?: Array<AppEditionDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoAuditLogListDto
 */
export interface PagedResultDtoAuditLogListDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoAuditLogListDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;AuditLogListDto&gt;}
     * @memberof PagedResultDtoAuditLogListDto
     */
    items?: Array<AuditLogListDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoFirendshipUserDto
 */
export interface PagedResultDtoFirendshipUserDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoFirendshipUserDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;FirendshipUserDto&gt;}
     * @memberof PagedResultDtoFirendshipUserDto
     */
    items?: Array<FirendshipUserDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoGetListAppStartPageDto
 */
export interface PagedResultDtoGetListAppStartPageDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoGetListAppStartPageDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;GetListAppStartPageDto&gt;}
     * @memberof PagedResultDtoGetListAppStartPageDto
     */
    items?: Array<GetListAppStartPageDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoGetListDemoDto
 */
export interface PagedResultDtoGetListDemoDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoGetListDemoDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;GetListDemoDto&gt;}
     * @memberof PagedResultDtoGetListDemoDto
     */
    items?: Array<GetListDemoDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoOrganizationUnitUserDto
 */
export interface PagedResultDtoOrganizationUnitUserDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoOrganizationUnitUserDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;OrganizationUnitUserDto&gt;}
     * @memberof PagedResultDtoOrganizationUnitUserDto
     */
    items?: Array<OrganizationUnitUserDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoOrganizationUnitUserListDto
 */
export interface PagedResultDtoOrganizationUnitUserListDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoOrganizationUnitUserListDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;OrganizationUnitUserListDto&gt;}
     * @memberof PagedResultDtoOrganizationUnitUserListDto
     */
    items?: Array<OrganizationUnitUserListDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoUserListDto
 */
export interface PagedResultDtoUserListDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoUserListDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;UserListDto&gt;}
     * @memberof PagedResultDtoUserListDto
     */
    items?: Array<UserListDto>;
}

/**
 * 
 * @export
 * @interface PagedResultDtoUserLoginAttemptDto
 */
export interface PagedResultDtoUserLoginAttemptDto {
    /**
     * 
     * @type {number}
     * @memberof PagedResultDtoUserLoginAttemptDto
     */
    totalCount?: number;
    /**
     * 
     * @type {Array&lt;UserLoginAttemptDto&gt;}
     * @memberof PagedResultDtoUserLoginAttemptDto
     */
    items?: Array<UserLoginAttemptDto>;
}

/**
 * 
 * @export
 * @interface PagedSortedAndFilteredInputDto
 */
export interface PagedSortedAndFilteredInputDto {
    /**
     * 
     * @type {string}
     * @memberof PagedSortedAndFilteredInputDto
     */
    filter?: string;
    /**
     * 
     * @type {string}
     * @memberof PagedSortedAndFilteredInputDto
     */
    sorting?: string;
    /**
     * 
     * @type {number}
     * @memberof PagedSortedAndFilteredInputDto
     */
    maxResultCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedSortedAndFilteredInputDto
     */
    skipCount?: number;
}

/**
 * 
 * @export
 * @interface PasswordComplexitySetting
 */
export interface PasswordComplexitySetting {
    /**
     * 
     * @type {number}
     * @memberof PasswordComplexitySetting
     */
    minLength?: number;
    /**
     * 
     * @type {number}
     * @memberof PasswordComplexitySetting
     */
    maxLength?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordComplexitySetting
     */
    useNumbers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordComplexitySetting
     */
    useUpperCaseLetters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordComplexitySetting
     */
    useLowerCaseLetters?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordComplexitySetting
     */
    usePunctuations?: boolean;
}

/**
 * 
 * @export
 * @interface PermissionDto
 */
export interface PermissionDto {
    /**
     * 
     * @type {string}
     * @memberof PermissionDto
     */
    parentName?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionDto
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionDto
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionDto
     */
    isGrantedByDefault?: boolean;
    /**
     * 
     * @type {Array&lt;PermissionDto&gt;}
     * @memberof PermissionDto
     */
    children?: Array<PermissionDto>;
}

/**
 * 
 * @export
 * @interface PhoneWithCaptchaInput
 */
export interface PhoneWithCaptchaInput {
    /**
     * 
     * @type {string}
     * @memberof PhoneWithCaptchaInput
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneWithCaptchaInput
     */
    captcha?: string;
}

/**
 * 
 * @export
 * @interface PushMsgInput
 */
export interface PushMsgInput {
    /**
     * 
     * @type {string}
     * @memberof PushMsgInput
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface PushSettingDto
 */
export interface PushSettingDto {
    /**
     * 
     * @type {string}
     * @memberof PushSettingDto
     */
    jPushAppKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PushSettingDto
     */
    jPushMasterSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof PushSettingDto
     */
    getuiAppID?: string;
    /**
     * 
     * @type {string}
     * @memberof PushSettingDto
     */
    getuiAppKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PushSettingDto
     */
    getuiMasterSecret?: string;
}

/**
 * 
 * @export
 * @interface RegisterByEmailInput
 */
export interface RegisterByEmailInput {
    /**
     * 
     * @type {string}
     * @memberof RegisterByEmailInput
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByEmailInput
     */
    emailAddress: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByEmailInput
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByEmailInput
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByEmailInput
     */
    captcha?: string;
}

/**
 * 
 * @export
 * @interface RegisterByPhoneNumberInput
 */
export interface RegisterByPhoneNumberInput {
    /**
     * 
     * @type {string}
     * @memberof RegisterByPhoneNumberInput
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByPhoneNumberInput
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByPhoneNumberInput
     */
    captcha?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByPhoneNumberInput
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterByPhoneNumberInput
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface RegisterInput
 */
export interface RegisterInput {
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    surname: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    emailAddress: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    captchaResponse?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterInput
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface RegisterOnlyPhoneNumberInput
 */
export interface RegisterOnlyPhoneNumberInput {
    /**
     * 
     * @type {string}
     * @memberof RegisterOnlyPhoneNumberInput
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterOnlyPhoneNumberInput
     */
    captcha?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterOnlyPhoneNumberInput
     */
    password: string;
}

/**
 * 
 * @export
 * @interface RegisterOutput
 */
export interface RegisterOutput {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterOutput
     */
    canLogin?: boolean;
}

/**
 * 
 * @export
 * @interface ResetPasswordByEmailInput
 */
export interface ResetPasswordByEmailInput {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordByEmailInput
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordByEmailInput
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordByEmailInput
     */
    verificationCode: string;
}

/**
 * 
 * @export
 * @interface ResetPasswordByPhoneNumberInput
 */
export interface ResetPasswordByPhoneNumberInput {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordByPhoneNumberInput
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordByPhoneNumberInput
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordByPhoneNumberInput
     */
    code?: string;
}

/**
 * 
 * @export
 * @interface RoleDto
 */
export interface RoleDto {
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDto
     */
    isStatic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDto
     */
    isDefault?: boolean;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof RoleDto
     */
    permissions?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RoleDto
     */
    id?: number;
}

/**
 * 角色信息
 * @export
 * @interface RoleEditDto
 */
export interface RoleEditDto {
    /**
     * 
     * @type {number}
     * @memberof RoleEditDto
     */
    id?: number;
    /**
     * 显示名
     * @type {string}
     * @memberof RoleEditDto
     */
    displayName: string;
    /**
     * 是否是默认角色
     * @type {boolean}
     * @memberof RoleEditDto
     */
    isDefault?: boolean;
}

/**
 * 角色
 * @export
 * @interface RoleListDto
 */
export interface RoleListDto {
    /**
     * 角色名
     * @type {string}
     * @memberof RoleListDto
     */
    name?: string;
    /**
     * 显示名
     * @type {string}
     * @memberof RoleListDto
     */
    displayName?: string;
    /**
     * 是否是系统内置角色
     * @type {boolean}
     * @memberof RoleListDto
     */
    isStatic?: boolean;
    /**
     * 是否是默认角色
     * @type {boolean}
     * @memberof RoleListDto
     */
    isDefault?: boolean;
    /**
     * 创建时间
     * @type {string}
     * @memberof RoleListDto
     */
    creationTime?: string;
    /**
     * 
     * @type {number}
     * @memberof RoleListDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface SecuritySettingDto
 */
export interface SecuritySettingDto {
    /**
     * 
     * @type {PasswordComplexitySetting}
     * @memberof SecuritySettingDto
     */
    passwordComplexity?: PasswordComplexitySetting;
    /**
     * 
     * @type {boolean}
     * @memberof SecuritySettingDto
     */
    useDefaultPasswordComplexity?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SecuritySettingDto
     */
    maxFailedAccessAttemptsBeforeLockout?: number;
    /**
     * 
     * @type {number}
     * @memberof SecuritySettingDto
     */
    defaultAccountLockoutSeconds?: number;
}

/**
 * 
 * @export
 * @interface SendConfirmEmailByCaptchaInput
 */
export interface SendConfirmEmailByCaptchaInput {
    /**
     * 
     * @type {string}
     * @memberof SendConfirmEmailByCaptchaInput
     */
    captcha?: string;
    /**
     * 
     * @type {string}
     * @memberof SendConfirmEmailByCaptchaInput
     */
    email: string;
}

/**
 * 
 * @export
 * @interface SetFileSettingDemoDto
 */
export interface SetFileSettingDemoDto {
    /**
     * 
     * @type {number}
     * @memberof SetFileSettingDemoDto
     */
    fileSize?: number;
    /**
     * 
     * @type {string}
     * @memberof SetFileSettingDemoDto
     */
    fileExtension?: string;
}

/**
 * 
 * @export
 * @interface SettingProperty
 */
export interface SettingProperty {
    /**
     * 
     * @type {string}
     * @memberof SettingProperty
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingProperty
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingProperty
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingProperty
     */
    type?: string;
    /**
     * 
     * @type {any}
     * @memberof SettingProperty
     */
    value?: any;
    /**
     * 
     * @type {string}
     * @memberof SettingProperty
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface SettingsEditIntput
 */
export interface SettingsEditIntput {
    /**
     * 
     * @type {UserManagementSettingDto}
     * @memberof SettingsEditIntput
     */
    userManagementSetting?: UserManagementSettingDto;
    /**
     * 
     * @type {SecuritySettingDto}
     * @memberof SettingsEditIntput
     */
    securitySetting?: SecuritySettingDto;
    /**
     * 
     * @type {OAuthSettingDto}
     * @memberof SettingsEditIntput
     */
    oAuthSetting?: OAuthSettingDto;
    /**
     * 
     * @type {SystemSettingDto}
     * @memberof SettingsEditIntput
     */
    systemSetting?: SystemSettingDto;
    /**
     * 
     * @type {PushSettingDto}
     * @memberof SettingsEditIntput
     */
    pushSetting?: PushSettingDto;
}

/**
 * 
 * @export
 * @interface SettingsEditOutput
 */
export interface SettingsEditOutput {
    /**
     * 
     * @type {Array&lt;SettingProperty&gt;}
     * @memberof SettingsEditOutput
     */
    userManagementSetting?: Array<SettingProperty>;
    /**
     * 
     * @type {Array&lt;SettingProperty&gt;}
     * @memberof SettingsEditOutput
     */
    securitySetting?: Array<SettingProperty>;
    /**
     * 
     * @type {Array&lt;SettingProperty&gt;}
     * @memberof SettingsEditOutput
     */
    oAuthSetting?: Array<SettingProperty>;
    /**
     * 
     * @type {Array&lt;SettingProperty&gt;}
     * @memberof SettingsEditOutput
     */
    systemSetting?: Array<SettingProperty>;
    /**
     * 
     * @type {Array&lt;SettingProperty&gt;}
     * @memberof SettingsEditOutput
     */
    pushSetting?: Array<SettingProperty>;
}

/**
 * 
 * @export
 * @interface SkinOutput
 */
export interface SkinOutput {
    /**
     * 
     * @type {string}
     * @memberof SkinOutput
     */
    name: string;
}

/**
 * 
 * @export
 * @interface SystemSettingDto
 */
export interface SystemSettingDto {
    /**
     * 
     * @type {string}
     * @memberof SystemSettingDto
     */
    imageUploadPath?: string;
}

/**
 * 
 * @export
 * @interface TenantLoginInfoDto
 */
export interface TenantLoginInfoDto {
    /**
     * 
     * @type {string}
     * @memberof TenantLoginInfoDto
     */
    tenancyName?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantLoginInfoDto
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof TenantLoginInfoDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface TenantNotification
 */
export interface TenantNotification {
    /**
     * 
     * @type {number}
     * @memberof TenantNotification
     */
    tenantId?: number;
    /**
     * 
     * @type {string}
     * @memberof TenantNotification
     */
    notificationName?: string;
    /**
     * 
     * @type {NotificationData}
     * @memberof TenantNotification
     */
    data?: NotificationData;
    /**
     * 
     * @type {string}
     * @memberof TenantNotification
     */
    entityType?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantNotification
     */
    entityTypeName?: string;
    /**
     * 
     * @type {any}
     * @memberof TenantNotification
     */
    entityId?: any;
    /**
     * 
     * @type {number}
     * @memberof TenantNotification
     */
    severity?: TenantNotification.SeverityEnum;
    /**
     * 
     * @type {Date}
     * @memberof TenantNotification
     */
    creationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof TenantNotification
     */
    id?: string;
}

/**
 * @export
 * @namespace TenantNotification
 */
export namespace TenantNotification {
    /**
     * @export
     * @enum {string}
     */
    export enum SeverityEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3,
        NUMBER_4 = <any> 4
    }
}

/**
 * 
 * @export
 * @interface UnblockUserInput
 */
export interface UnblockUserInput {
    /**
     * 
     * @type {number}
     * @memberof UnblockUserInput
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof UnblockUserInput
     */
    tenantId?: number;
}

/**
 * 
 * @export
 * @interface UpdateAndroidAppEditionInput
 */
export interface UpdateAndroidAppEditionInput {
    /**
     * 
     * @type {number}
     * @memberof UpdateAndroidAppEditionInput
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateAndroidAppEditionInput
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAndroidAppEditionInput
     */
    aboutUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAndroidAppEditionInput
     */
    installationPackage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAndroidAppEditionInput
     */
    isMandatoryUpdate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAndroidAppEditionInput
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateAndroidAppEditionInput
     */
    describe?: string;
}

/**
 * 
 * @export
 * @interface UpdateAppStartPageDto
 */
export interface UpdateAppStartPageDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateAppStartPageDto
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppStartPageDto
     */
    platform?: UpdateAppStartPageDto.PlatformEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppStartPageDto
     */
    widthPx?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppStartPageDto
     */
    highPx?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppStartPageDto
     */
    url?: string;
}

/**
 * @export
 * @namespace UpdateAppStartPageDto
 */
export namespace UpdateAppStartPageDto {
    /**
     * @export
     * @enum {string}
     */
    export enum PlatformEnum {
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
}

/**
 * 
 * @export
 * @interface UpdateCurrentUserInput
 */
export interface UpdateCurrentUserInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserInput
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserInput
     */
    surname?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserInput
     */
    emailAddress: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCurrentUserInput
     */
    phoneNumber?: string;
}

/**
 * 
 * @export
 * @interface UpdateDemoDto
 */
export interface UpdateDemoDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateDemoDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateDemoDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDemoDto
     */
    longText?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDemoDto
     */
    group?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDemoDto
     */
    isActivate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateDemoDto
     */
    sort?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDemoDto
     */
    weight?: number;
    /**
     * 
     * @type {Date}
     * @memberof UpdateDemoDto
     */
    publishTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof UpdateDemoDto
     */
    avatar?: string;
    /**
     * 
     * @type {Location}
     * @memberof UpdateDemoDto
     */
    location?: Location;
}

/**
 * 
 * @export
 * @interface UpdateIOSAppEditionInput
 */
export interface UpdateIOSAppEditionInput {
    /**
     * 
     * @type {number}
     * @memberof UpdateIOSAppEditionInput
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateIOSAppEditionInput
     */
    itunesUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIOSAppEditionInput
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIOSAppEditionInput
     */
    aboutUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIOSAppEditionInput
     */
    installationPackage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateIOSAppEditionInput
     */
    isMandatoryUpdate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateIOSAppEditionInput
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateIOSAppEditionInput
     */
    describe?: string;
}

/**
 * 更新菜单信息
 * @export
 * @interface UpdateMenuInput
 */
export interface UpdateMenuInput {
    /**
     * 菜单Id
     * @type {number}
     * @memberof UpdateMenuInput
     */
    id?: number;
    /**
     * 显示名称
     * @type {string}
     * @memberof UpdateMenuInput
     */
    displayName?: string;
    /**
     * 图标class
     * @type {string}
     * @memberof UpdateMenuInput
     */
    icon?: string;
    /**
     * 菜单是否可见
     * @type {boolean}
     * @memberof UpdateMenuInput
     */
    isVisible?: boolean;
    /**
     * 权限限制
     * @type {string}
     * @memberof UpdateMenuInput
     */
    requiredPermissionName?: string;
    /**
     * 目标链接
     * @type {string}
     * @memberof UpdateMenuInput
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface UpdateNotificationSettingsInput
 */
export interface UpdateNotificationSettingsInput {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationSettingsInput
     */
    receiveNotifications?: boolean;
    /**
     * 
     * @type {Array&lt;NotificationSubscriptionDto&gt;}
     * @memberof UpdateNotificationSettingsInput
     */
    notifications?: Array<NotificationSubscriptionDto>;
}

/**
 * 更新组织机构信息请求
 * @export
 * @interface UpdateOrganizationUnitInput
 */
export interface UpdateOrganizationUnitInput {
    /**
     * 组织机构ID
     * @type {number}
     * @memberof UpdateOrganizationUnitInput
     */
    id?: number;
    /**
     * 组织机构名称
     * @type {string}
     * @memberof UpdateOrganizationUnitInput
     */
    displayName: string;
}

/**
 * 
 * @export
 * @interface UpdateProfilePictureInput
 */
export interface UpdateProfilePictureInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateProfilePictureInput
     */
    fileName: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfilePictureInput
     */
    x?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfilePictureInput
     */
    y?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfilePictureInput
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProfilePictureInput
     */
    height?: number;
}

/**
 * 修改用户权限参数
 * @export
 * @interface UpdateUserPermissionsInput
 */
export interface UpdateUserPermissionsInput {
    /**
     * 
     * @type {number}
     * @memberof UpdateUserPermissionsInput
     */
    id?: number;
    /**
     * 权限集合
     * @type {Array&lt;string&gt;}
     * @memberof UpdateUserPermissionsInput
     */
    grantedPermissionNames: Array<string>;
}

/**
 * 编辑用户
 * @export
 * @interface UserEditDto
 */
export interface UserEditDto {
    /**
     * Set null to create a new user. Set user's Id to update a user
     * @type {number}
     * @memberof UserEditDto
     */
    id?: number;
    /**
     * 姓名
     * @type {string}
     * @memberof UserEditDto
     */
    name: string;
    /**
     * 姓氏    【可不使用】
     * @type {string}
     * @memberof UserEditDto
     */
    surname?: string;
    /**
     * 登录名
     * @type {string}
     * @memberof UserEditDto
     */
    userName: string;
    /**
     * 邮箱
     * @type {string}
     * @memberof UserEditDto
     */
    emailAddress?: string;
    /**
     * 手机号
     * @type {string}
     * @memberof UserEditDto
     */
    phoneNumber?: string;
    /**
     * 密码
     * @type {string}
     * @memberof UserEditDto
     */
    password?: string;
    /**
     * 是否激活
     * @type {boolean}
     * @memberof UserEditDto
     */
    isActive?: boolean;
    /**
     * 下次登录需要修改密码
     * @type {boolean}
     * @memberof UserEditDto
     */
    shouldChangePasswordOnNextLogin?: boolean;
    /**
     * 是否启用锁定
     * @type {boolean}
     * @memberof UserEditDto
     */
    isLockoutEnabled?: boolean;
}

/**
 * 
 * @export
 * @interface UserIdInput
 */
export interface UserIdInput {
    /**
     * 
     * @type {number}
     * @memberof UserIdInput
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface UserListDto
 */
export interface UserListDto {
    /**
     * 
     * @type {number}
     * @memberof UserListDto
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    surname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    emailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    profilePictureId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserListDto
     */
    isEmailConfirmed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserListDto
     */
    isPhoneNumberConfirmed?: boolean;
    /**
     * 
     * @type {Array&lt;UserListRoleDto&gt;}
     * @memberof UserListDto
     */
    roles?: Array<UserListRoleDto>;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    lastLoginTime?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserListDto
     */
    isActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserListDto
     */
    creationTime?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserListDto
     */
    isLocked?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof UserListDto
     */
    lockoutEndDateUtc?: Date;
}

/**
 * 
 * @export
 * @interface UserListRoleDto
 */
export interface UserListRoleDto {
    /**
     * 
     * @type {number}
     * @memberof UserListRoleDto
     */
    roleId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserListRoleDto
     */
    roleName?: string;
}

/**
 * 
 * @export
 * @interface UserLoginAttemptDto
 */
export interface UserLoginAttemptDto {
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    tenancyName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    userNameOrEmailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    clientIpAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    clientName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    browserInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAttemptDto
     */
    creationTime?: string;
}

/**
 * 
 * @export
 * @interface UserLoginInfoDto
 */
export interface UserLoginInfoDto {
    /**
     * 
     * @type {string}
     * @memberof UserLoginInfoDto
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginInfoDto
     */
    surname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginInfoDto
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginInfoDto
     */
    emailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginInfoDto
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginInfoDto
     */
    profile?: string;
    /**
     * 
     * @type {number}
     * @memberof UserLoginInfoDto
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface UserManagementSettingDto
 */
export interface UserManagementSettingDto {
    /**
     * 
     * @type {boolean}
     * @memberof UserManagementSettingDto
     */
    allowSelfRegistration?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserManagementSettingDto
     */
    isEmailConfirmationRequiredForLogin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserManagementSettingDto
     */
    isPhoneNumberConfirmationRequiredForLogin?: boolean;
}

/**
 * 
 * @export
 * @interface UserMenuItem
 */
export interface UserMenuItem {
    /**
     * 
     * @type {string}
     * @memberof UserMenuItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMenuItem
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof UserMenuItem
     */
    displayName?: string;
    /**
     * 
     * @type {number}
     * @memberof UserMenuItem
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof UserMenuItem
     */
    url?: string;
    /**
     * 
     * @type {any}
     * @memberof UserMenuItem
     */
    customData?: any;
    /**
     * 
     * @type {string}
     * @memberof UserMenuItem
     */
    target?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserMenuItem
     */
    isEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserMenuItem
     */
    isVisible?: boolean;
    /**
     * 
     * @type {Array&lt;UserMenuItem&gt;}
     * @memberof UserMenuItem
     */
    items?: Array<UserMenuItem>;
}

/**
 * 
 * @export
 * @interface UserNotification
 */
export interface UserNotification {
    /**
     * 
     * @type {number}
     * @memberof UserNotification
     */
    tenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserNotification
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof UserNotification
     */
    state?: UserNotification.StateEnum;
    /**
     * 
     * @type {TenantNotification}
     * @memberof UserNotification
     */
    notification?: TenantNotification;
    /**
     * 
     * @type {string}
     * @memberof UserNotification
     */
    id?: string;
}

/**
 * @export
 * @namespace UserNotification
 */
export namespace UserNotification {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface UserRoleDto
 */
export interface UserRoleDto {
    /**
     * 
     * @type {number}
     * @memberof UserRoleDto
     */
    roleId?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRoleDto
     */
    roleName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRoleDto
     */
    roleDisplayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRoleDto
     */
    isAssigned?: boolean;
}

/**
 * 用户加入组织请求
 * @export
 * @interface UserToOrganizationUnitInput
 */
export interface UserToOrganizationUnitInput {
    /**
     * 用户ID
     * @type {number}
     * @memberof UserToOrganizationUnitInput
     */
    userId?: number;
    /**
     * 组织机构ID
     * @type {number}
     * @memberof UserToOrganizationUnitInput
     */
    organizationUnitId?: number;
}

/**
 * 
 * @export
 * @interface UsersToOrganizationUnitInput
 */
export interface UsersToOrganizationUnitInput {
    /**
     * 
     * @type {string}
     * @memberof UsersToOrganizationUnitInput
     */
    userIdListStr?: string;
    /**
     * 
     * @type {number}
     * @memberof UsersToOrganizationUnitInput
     */
    organizationUnitId?: number;
}

/**
 * 
 * @export
 * @interface ValidationErrorInfo
 */
export interface ValidationErrorInfo {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorInfo
     */
    message?: string;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof ValidationErrorInfo
     */
    members?: Array<string>;
}

/**
 * 
 * @export
 * @interface VerificationCodeInput
 */
export interface VerificationCodeInput {
    /**
     * 
     * @type {string}
     * @memberof VerificationCodeInput
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationCodeInput
     */
    phoneNumber: string;
}

/**
 * 
 * @export
 * @interface VersionInput
 */
export interface VersionInput {
    /**
     * 
     * @type {string}
     * @memberof VersionInput
     */
    version?: string;
}


/**
 * AbpCacheApi - fetch parameter creator
 * @export
 */
export const AbpCacheApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClearCacheModel} model 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpCacheClear(model: ClearCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling abpCacheClear.');
            }
            const localVarPath = `/api/AbpCache/Clear`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClearCacheModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClearAllCacheModel} model 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpCacheClearAll(model: ClearAllCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling abpCacheClearAll.');
            }
            const localVarPath = `/api/AbpCache/ClearAll`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClearAllCacheModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbpCacheApi - functional programming interface
 * @export
 */
export const AbpCacheApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClearCacheModel} model 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpCacheClear(model: ClearCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AjaxResponse> {
            const localVarFetchArgs = AbpCacheApiFetchParamCreator(configuration).abpCacheClear(model, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ClearAllCacheModel} model 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpCacheClearAll(model: ClearAllCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AjaxResponse> {
            const localVarFetchArgs = AbpCacheApiFetchParamCreator(configuration).abpCacheClearAll(model, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AbpCacheApi - factory interface
 * @export
 */
export const AbpCacheApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ClearCacheModel} model 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpCacheClear(model: ClearCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AbpCacheApiFp(configuration).abpCacheClear(model, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ClearAllCacheModel} model 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpCacheClearAll(model: ClearAllCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AbpCacheApiFp(configuration).abpCacheClearAll(model, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * AbpCacheApi - object-oriented interface
 * @export
 * @class AbpCacheApi
 * @extends {BaseAPI}
 */
export class AbpCacheApi extends BaseAPI {
    /**
     * 
     * @param {} model 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbpCacheApi
     */
    public abpCacheClear(model: ClearCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AbpCacheApiFp(this.configuration).abpCacheClear(model, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} model 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbpCacheApi
     */
    public abpCacheClearAll(model: ClearAllCacheModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AbpCacheApiFp(this.configuration).abpCacheClearAll(model, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * AbpServiceProxiesApi - fetch parameter creator
 * @export
 */
export const AbpServiceProxiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpServiceProxiesGet(name: string, X_XSRF_TOKEN?: string, authorization?: string, type?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling abpServiceProxiesGet.');
            }
            const localVarPath = `/api/AbpServiceProxies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbpServiceProxiesApi - functional programming interface
 * @export
 */
export const AbpServiceProxiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpServiceProxiesGet(name: string, X_XSRF_TOKEN?: string, authorization?: string, type?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = AbpServiceProxiesApiFetchParamCreator(configuration).abpServiceProxiesGet(name, X_XSRF_TOKEN, authorization, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AbpServiceProxiesApi - factory interface
 * @export
 */
export const AbpServiceProxiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {number} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abpServiceProxiesGet(name: string, X_XSRF_TOKEN?: string, authorization?: string, type?: number, options?: any) {
            return AbpServiceProxiesApiFp(configuration).abpServiceProxiesGet(name, X_XSRF_TOKEN, authorization, type, options)(fetch, basePath);
        },
    };
};

/**
 * AbpServiceProxiesApi - object-oriented interface
 * @export
 * @class AbpServiceProxiesApi
 * @extends {BaseAPI}
 */
export class AbpServiceProxiesApi extends BaseAPI {
    /**
     * 
     * @param {} name 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbpServiceProxiesApi
     */
    public abpServiceProxiesGet(name: string, X_XSRF_TOKEN?: string, authorization?: string, type?: number, options?: any) {
        return AbpServiceProxiesApiFp(this.configuration).abpServiceProxiesGet(name, X_XSRF_TOKEN, authorization, type, options)(this.fetch, this.basePath);
    }

}

/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginModel} loginModel 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthenticate(loginModel: LoginModel, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'loginModel' is not null or undefined
            if (loginModel === null || loginModel === undefined) {
                throw new RequiredError('loginModel','Required parameter loginModel was null or undefined when calling accountAuthenticate.');
            }
            const localVarPath = `/api/Account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(loginModel || {}) : (loginModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BindingThirdPartyInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountBindingThirdParty(input: BindingThirdPartyInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAccountBindingThirdParty.');
            }
            const localVarPath = `/api/services/app/account/BindingThirdParty`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BindingThirdPartyInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IsTenantAvailableInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountIsTenantAvailable(input: IsTenantAvailableInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAccountIsTenantAvailable.');
            }
            const localVarPath = `/api/services/app/account/IsTenantAvailable`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IsTenantAvailableInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAccountSendPhoneNumberCode.');
            }
            const localVarPath = `/api/services/app/account/SendPhoneNumberCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PhoneWithCaptchaInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginModel} loginModel 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthenticate(loginModel: LoginModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AjaxResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountAuthenticate(loginModel, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BindingThirdPartyInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountBindingThirdParty(input: BindingThirdPartyInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).appAccountBindingThirdParty(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {IsTenantAvailableInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountIsTenantAvailable(input: IsTenantAvailableInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IsTenantAvailableOutput> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).appAccountIsTenantAvailable(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).appAccountSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {LoginModel} loginModel 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAuthenticate(loginModel: LoginModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AccountApiFp(configuration).accountAuthenticate(loginModel, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BindingThirdPartyInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountBindingThirdParty(input: BindingThirdPartyInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AccountApiFp(configuration).appAccountBindingThirdParty(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {IsTenantAvailableInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountIsTenantAvailable(input: IsTenantAvailableInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AccountApiFp(configuration).appAccountIsTenantAvailable(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAccountSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AccountApiFp(configuration).appAccountSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {} loginModel 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountAuthenticate(loginModel: LoginModel, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AccountApiFp(this.configuration).accountAuthenticate(loginModel, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public appAccountBindingThirdParty(input: BindingThirdPartyInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AccountApiFp(this.configuration).appAccountBindingThirdParty(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public appAccountIsTenantAvailable(input: IsTenantAvailableInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AccountApiFp(this.configuration).appAccountIsTenantAvailable(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public appAccountSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AccountApiFp(this.configuration).appAccountSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * ActiveApi - fetch parameter creator
 * @export
 */
export const ActiveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmEmailCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveConfirmEmailByCode(input: ConfirmEmailCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appActiveConfirmEmailByCode.');
            }
            const localVarPath = `/api/services/app/active/ConfirmEmailByCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfirmEmailCodeInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerificationCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appActiveConfirmPhoneNumberByCode.');
            }
            const localVarPath = `/api/services/app/active/ConfirmPhoneNumberByCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerificationCodeInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveSendConfirmEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appActiveSendConfirmEmailCode.');
            }
            const localVarPath = `/api/services/app/active/SendConfirmEmailCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendConfirmEmailByCaptchaInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerificationCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveSendConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appActiveSendConfirmPhoneNumberByCode.');
            }
            const localVarPath = `/api/services/app/active/SendConfirmPhoneNumberByCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerificationCodeInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveApi - functional programming interface
 * @export
 */
export const ActiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmEmailCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveConfirmEmailByCode(input: ConfirmEmailCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ActiveApiFetchParamCreator(configuration).appActiveConfirmEmailByCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VerificationCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ActiveApiFetchParamCreator(configuration).appActiveConfirmPhoneNumberByCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveSendConfirmEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ActiveApiFetchParamCreator(configuration).appActiveSendConfirmEmailCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VerificationCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveSendConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ActiveApiFetchParamCreator(configuration).appActiveSendConfirmPhoneNumberByCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActiveApi - factory interface
 * @export
 */
export const ActiveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ConfirmEmailCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveConfirmEmailByCode(input: ConfirmEmailCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ActiveApiFp(configuration).appActiveConfirmEmailByCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VerificationCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ActiveApiFp(configuration).appActiveConfirmPhoneNumberByCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveSendConfirmEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ActiveApiFp(configuration).appActiveSendConfirmEmailCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VerificationCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appActiveSendConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ActiveApiFp(configuration).appActiveSendConfirmPhoneNumberByCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * ActiveApi - object-oriented interface
 * @export
 * @class ActiveApi
 * @extends {BaseAPI}
 */
export class ActiveApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveApi
     */
    public appActiveConfirmEmailByCode(input: ConfirmEmailCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ActiveApiFp(this.configuration).appActiveConfirmEmailByCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveApi
     */
    public appActiveConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ActiveApiFp(this.configuration).appActiveConfirmPhoneNumberByCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveApi
     */
    public appActiveSendConfirmEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ActiveApiFp(this.configuration).appActiveSendConfirmEmailCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveApi
     */
    public appActiveSendConfirmPhoneNumberByCode(input: VerificationCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ActiveApiFp(this.configuration).appActiveSendConfirmPhoneNumberByCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * AppEditionsApi - fetch parameter creator
 * @export
 */
export const AppEditionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsCheckUpdate.');
            }
            const localVarPath = `/api/services/app/appEditions/CheckUpdate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VersionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateAndroidAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCreateAndroidAppEdition(input: CreateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsCreateAndroidAppEdition.');
            }
            const localVarPath = `/api/services/app/appEditions/CreateAndroidAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAndroidAppEditionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateIOSAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCreateIOSAppEdition(input: CreateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsCreateIOSAppEdition.');
            }
            const localVarPath = `/api/services/app/appEditions/CreateIOSAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateIOSAppEditionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsDeleteAppEdition(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsDeleteAppEdition.');
            }
            const localVarPath = `/api/services/app/appEditions/DeleteAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsDownloadAppEdition(id: number, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling appAppEditionsDownloadAppEdition.');
            }
            const localVarPath = `/api/services/app/appEditions/DownloadAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAbout(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsGetAbout.');
            }
            const localVarPath = `/api/services/app/appEditions/GetAbout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VersionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAboutAndCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsGetAboutAndCheckUpdate.');
            }
            const localVarPath = `/api/services/app/appEditions/GetAboutAndCheckUpdate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VersionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAppEditionsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAppEditions(input: GetAppEditionsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsGetAppEditions.');
            }
            const localVarPath = `/api/services/app/appEditions/GetAppEditions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetAppEditionsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAndroidAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUpdateAndroidAppEdition(input: UpdateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsUpdateAndroidAppEdition.');
            }
            const localVarPath = `/api/services/app/appEditions/UpdateAndroidAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAndroidAppEditionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateIOSAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUpdateIOSAppEdition(input: UpdateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppEditionsUpdateIOSAppEdition.');
            }
            const localVarPath = `/api/services/app/appEditions/UpdateIOSAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateIOSAppEditionInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUploadAppEdition(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/appEditions/UploadAppEdition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppEditionsApi - functional programming interface
 * @export
 */
export const AppEditionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckUpdateOutput> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsCheckUpdate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateAndroidAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCreateAndroidAppEdition(input: CreateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsCreateAndroidAppEdition(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateIOSAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCreateIOSAppEdition(input: CreateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsCreateIOSAppEdition(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsDeleteAppEdition(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsDeleteAppEdition(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsDownloadAppEdition(id: number, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsDownloadAppEdition(id, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAbout(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AboutOutput> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsGetAbout(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAboutAndCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAboutAndCheckUpdateOutput> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsGetAboutAndCheckUpdate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetAppEditionsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAppEditions(input: GetAppEditionsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoAppEditionDto> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsGetAppEditions(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateAndroidAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUpdateAndroidAppEdition(input: UpdateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsUpdateAndroidAppEdition(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateIOSAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUpdateIOSAppEdition(input: UpdateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsUpdateIOSAppEdition(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUploadAppEdition(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AppEditionsApiFetchParamCreator(configuration).appAppEditionsUploadAppEdition(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppEditionsApi - factory interface
 * @export
 */
export const AppEditionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsCheckUpdate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateAndroidAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCreateAndroidAppEdition(input: CreateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsCreateAndroidAppEdition(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateIOSAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsCreateIOSAppEdition(input: CreateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsCreateIOSAppEdition(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsDeleteAppEdition(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsDeleteAppEdition(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsDownloadAppEdition(id: number, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsDownloadAppEdition(id, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAbout(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsGetAbout(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {VersionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAboutAndCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsGetAboutAndCheckUpdate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetAppEditionsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsGetAppEditions(input: GetAppEditionsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsGetAppEditions(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateAndroidAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUpdateAndroidAppEdition(input: UpdateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsUpdateAndroidAppEdition(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateIOSAppEditionInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUpdateIOSAppEdition(input: UpdateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsUpdateIOSAppEdition(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppEditionsUploadAppEdition(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppEditionsApiFp(configuration).appAppEditionsUploadAppEdition(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * AppEditionsApi - object-oriented interface
 * @export
 * @class AppEditionsApi
 * @extends {BaseAPI}
 */
export class AppEditionsApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsCheckUpdate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsCreateAndroidAppEdition(input: CreateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsCreateAndroidAppEdition(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsCreateIOSAppEdition(input: CreateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsCreateIOSAppEdition(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsDeleteAppEdition(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsDeleteAppEdition(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} id 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsDownloadAppEdition(id: number, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsDownloadAppEdition(id, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsGetAbout(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsGetAbout(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsGetAboutAndCheckUpdate(input: VersionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsGetAboutAndCheckUpdate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsGetAppEditions(input: GetAppEditionsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsGetAppEditions(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsUpdateAndroidAppEdition(input: UpdateAndroidAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsUpdateAndroidAppEdition(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsUpdateIOSAppEdition(input: UpdateIOSAppEditionInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsUpdateIOSAppEdition(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppEditionsApi
     */
    public appAppEditionsUploadAppEdition(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppEditionsApiFp(this.configuration).appAppEditionsUploadAppEdition(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * AppStartPageApi - fetch parameter creator
 * @export
 */
export const AppStartPageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAppStartPageDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageCreate(input: CreateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageCreate.');
            }
            const localVarPath = `/api/services/app/appStartPage/Create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAppStartPageDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageDelete.');
            }
            const localVarPath = `/api/services/app/appStartPage/Delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt32" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArrayDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageDeleteBatch.');
            }
            const localVarPath = `/api/services/app/appStartPage/DeleteBatch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArrayDtoInt32" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageGet.');
            }
            const localVarPath = `/api/services/app/appStartPage/Get`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt32" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PagedSortedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageGetAll.');
            }
            const localVarPath = `/api/services/app/appStartPage/GetAll`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PagedSortedAndFilteredInputDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAppStartPageInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGetAppStartPage(input: GetAppStartPageInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageGetAppStartPage.');
            }
            const localVarPath = `/api/services/app/appStartPage/GetAppStartPage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetAppStartPageInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IsUpatedInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageIsUpdated(input: IsUpatedInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageIsUpdated.');
            }
            const localVarPath = `/api/services/app/appStartPage/IsUpdated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IsUpatedInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAppStartPageDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageUpdate(input: UpdateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAppStartPageUpdate.');
            }
            const localVarPath = `/api/services/app/appStartPage/Update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAppStartPageDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppStartPageApi - functional programming interface
 * @export
 */
export const AppStartPageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAppStartPageDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageCreate(input: CreateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetListAppStartPageDto> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageCreate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageDelete(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ArrayDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageDeleteBatch(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetListAppStartPageDto> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageGet(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PagedSortedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoGetListAppStartPageDto> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageGetAll(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetAppStartPageInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGetAppStartPage(input: GetAppStartPageInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAppStartPageDto> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageGetAppStartPage(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {IsUpatedInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageIsUpdated(input: IsUpatedInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageIsUpdated(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateAppStartPageDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageUpdate(input: UpdateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetListAppStartPageDto> {
            const localVarFetchArgs = AppStartPageApiFetchParamCreator(configuration).appAppStartPageUpdate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppStartPageApi - factory interface
 * @export
 */
export const AppStartPageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateAppStartPageDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageCreate(input: CreateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageCreate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageDelete(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ArrayDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageDeleteBatch(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageGet(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PagedSortedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageGetAll(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetAppStartPageInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageGetAppStartPage(input: GetAppStartPageInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageGetAppStartPage(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {IsUpatedInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageIsUpdated(input: IsUpatedInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageIsUpdated(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateAppStartPageDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAppStartPageUpdate(input: UpdateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AppStartPageApiFp(configuration).appAppStartPageUpdate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * AppStartPageApi - object-oriented interface
 * @export
 * @class AppStartPageApi
 * @extends {BaseAPI}
 */
export class AppStartPageApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageCreate(input: CreateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageCreate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageDelete(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageDeleteBatch(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageGet(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageGetAll(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageGetAppStartPage(input: GetAppStartPageInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageGetAppStartPage(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageIsUpdated(input: IsUpatedInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageIsUpdated(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppStartPageApi
     */
    public appAppStartPageUpdate(input: UpdateAppStartPageDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AppStartPageApiFp(this.configuration).appAppStartPageUpdate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * AuditLogApi - fetch parameter creator
 * @export
 */
export const AuditLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetAuditLogsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAuditLogGetAuditLogs(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAuditLogGetAuditLogs.');
            }
            const localVarPath = `/api/services/app/auditLog/GetAuditLogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetAuditLogsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetAuditLogsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAuditLogGetAuditLogsToExcel(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appAuditLogGetAuditLogsToExcel.');
            }
            const localVarPath = `/api/services/app/auditLog/GetAuditLogsToExcel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetAuditLogsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogApi - functional programming interface
 * @export
 */
export const AuditLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetAuditLogsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAuditLogGetAuditLogs(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoAuditLogListDto> {
            const localVarFetchArgs = AuditLogApiFetchParamCreator(configuration).appAuditLogGetAuditLogs(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetAuditLogsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAuditLogGetAuditLogsToExcel(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileDto> {
            const localVarFetchArgs = AuditLogApiFetchParamCreator(configuration).appAuditLogGetAuditLogsToExcel(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuditLogApi - factory interface
 * @export
 */
export const AuditLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {GetAuditLogsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAuditLogGetAuditLogs(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AuditLogApiFp(configuration).appAuditLogGetAuditLogs(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetAuditLogsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appAuditLogGetAuditLogsToExcel(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return AuditLogApiFp(configuration).appAuditLogGetAuditLogsToExcel(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
export class AuditLogApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public appAuditLogGetAuditLogs(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AuditLogApiFp(this.configuration).appAuditLogGetAuditLogs(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public appAuditLogGetAuditLogsToExcel(input: GetAuditLogsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return AuditLogApiFp(this.configuration).appAuditLogGetAuditLogsToExcel(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * ChatApi - fetch parameter creator
 * @export
 */
export const ChatApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/chat/GetUserChatFriendsWithSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUserChatMessagesInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatGetUserChatMessages(input: GetUserChatMessagesInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appChatGetUserChatMessages.');
            }
            const localVarPath = `/api/services/app/chat/GetUserChatMessages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetUserChatMessagesInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MarkAllUnreadMessagesOfUserAsReadInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatMarkAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appChatMarkAllUnreadMessagesOfUserAsRead.');
            }
            const localVarPath = `/api/services/app/chat/MarkAllUnreadMessagesOfUserAsRead`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MarkAllUnreadMessagesOfUserAsReadInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserChatFriendsWithSettingsOutput> {
            const localVarFetchArgs = ChatApiFetchParamCreator(configuration).appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetUserChatMessagesInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatGetUserChatMessages(input: GetUserChatMessagesInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResultDtoChatMessageDto> {
            const localVarFetchArgs = ChatApiFetchParamCreator(configuration).appChatGetUserChatMessages(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {MarkAllUnreadMessagesOfUserAsReadInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatMarkAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChatApiFetchParamCreator(configuration).appChatMarkAllUnreadMessagesOfUserAsRead(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ChatApiFp(configuration).appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetUserChatMessagesInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatGetUserChatMessages(input: GetUserChatMessagesInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ChatApiFp(configuration).appChatGetUserChatMessages(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {MarkAllUnreadMessagesOfUserAsReadInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appChatMarkAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ChatApiFp(configuration).appChatMarkAllUnreadMessagesOfUserAsRead(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ChatApiFp(this.configuration).appChatGetUserChatFriendsWithSettings(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public appChatGetUserChatMessages(input: GetUserChatMessagesInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ChatApiFp(this.configuration).appChatGetUserChatMessages(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public appChatMarkAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ChatApiFp(this.configuration).appChatMarkAllUnreadMessagesOfUserAsRead(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigurationApi - fetch parameter creator
 * @export
 */
export const ConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeUiThemeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationChangeUiTheme(input: ChangeUiThemeInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appConfigurationChangeUiTheme.');
            }
            const localVarPath = `/api/services/app/configuration/ChangeUiTheme`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeUiThemeInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetAllSettings(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/configuration/GetAllSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetClientSetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/configuration/GetClientSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetUiTheme(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/configuration/GetUiTheme`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SettingsEditIntput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationUpdateAllSettings(input: SettingsEditIntput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appConfigurationUpdateAllSettings.');
            }
            const localVarPath = `/api/services/app/configuration/UpdateAllSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SettingsEditIntput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeUiThemeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationChangeUiTheme(input: ChangeUiThemeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).appConfigurationChangeUiTheme(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetAllSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SettingsEditOutput> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).appConfigurationGetAllSettings(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetClientSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientSettingDto> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).appConfigurationGetClientSetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetUiTheme(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkinOutput> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).appConfigurationGetUiTheme(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SettingsEditIntput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationUpdateAllSettings(input: SettingsEditIntput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).appConfigurationUpdateAllSettings(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ChangeUiThemeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationChangeUiTheme(input: ChangeUiThemeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ConfigurationApiFp(configuration).appConfigurationChangeUiTheme(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetAllSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ConfigurationApiFp(configuration).appConfigurationGetAllSettings(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetClientSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ConfigurationApiFp(configuration).appConfigurationGetClientSetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationGetUiTheme(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ConfigurationApiFp(configuration).appConfigurationGetUiTheme(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SettingsEditIntput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appConfigurationUpdateAllSettings(input: SettingsEditIntput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ConfigurationApiFp(configuration).appConfigurationUpdateAllSettings(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public appConfigurationChangeUiTheme(input: ChangeUiThemeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ConfigurationApiFp(this.configuration).appConfigurationChangeUiTheme(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public appConfigurationGetAllSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ConfigurationApiFp(this.configuration).appConfigurationGetAllSettings(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public appConfigurationGetClientSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ConfigurationApiFp(this.configuration).appConfigurationGetClientSetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public appConfigurationGetUiTheme(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ConfigurationApiFp(this.configuration).appConfigurationGetUiTheme(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public appConfigurationUpdateAllSettings(input: SettingsEditIntput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ConfigurationApiFp(this.configuration).appConfigurationUpdateAllSettings(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * DemoApi - fetch parameter creator
 * @export
 */
export const DemoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoCreate(input: CreateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDemoCreate.');
            }
            const localVarPath = `/api/services/app/demo/Create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDemoDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDemoDelete.');
            }
            const localVarPath = `/api/services/app/demo/Delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt32" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArrayDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDemoDeleteBatch.');
            }
            const localVarPath = `/api/services/app/demo/DeleteBatch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArrayDtoInt32" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDemoGet.');
            }
            const localVarPath = `/api/services/app/demo/Get`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt32" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PagedSortedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDemoGetAll.');
            }
            const localVarPath = `/api/services/app/demo/GetAll`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PagedSortedAndFilteredInputDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PushMsgInput} msg 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoJPushMsg(msg: PushMsgInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'msg' is not null or undefined
            if (msg === null || msg === undefined) {
                throw new RequiredError('msg','Required parameter msg was null or undefined when calling appDemoJPushMsg.');
            }
            const localVarPath = `/api/services/app/demo/JPushMsg`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PushMsgInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(msg || {}) : (msg || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoUpdate(input: UpdateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDemoUpdate.');
            }
            const localVarPath = `/api/services/app/demo/Update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDemoDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemoApi - functional programming interface
 * @export
 */
export const DemoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoCreate(input: CreateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetListDemoDto> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoCreate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoDelete(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ArrayDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoDeleteBatch(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetListDemoDto> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoGet(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PagedSortedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoGetListDemoDto> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoGetAll(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PushMsgInput} msg 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoJPushMsg(msg: PushMsgInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoJPushMsg(msg, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoUpdate(input: UpdateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetListDemoDto> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).appDemoUpdate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DemoApi - factory interface
 * @export
 */
export const DemoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoCreate(input: CreateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoCreate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoDelete(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ArrayDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoDeleteBatch(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt32} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoGet(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PagedSortedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoGetAll(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PushMsgInput} msg 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoJPushMsg(msg: PushMsgInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoJPushMsg(msg, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDemoUpdate(input: UpdateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DemoApiFp(configuration).appDemoUpdate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * DemoApi - object-oriented interface
 * @export
 * @class DemoApi
 * @extends {BaseAPI}
 */
export class DemoApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoCreate(input: CreateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoCreate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoDelete(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoDelete(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoDeleteBatch(input: ArrayDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoDeleteBatch(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoGet(input: EntityDtoInt32, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoGet(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoGetAll(input: PagedSortedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoGetAll(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} msg 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoJPushMsg(msg: PushMsgInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoJPushMsg(msg, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public appDemoUpdate(input: UpdateDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DemoApiFp(this.configuration).appDemoUpdate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * DragVerificationApi - fetch parameter creator
 * @export
 */
export const DragVerificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDragVerificationCheckCode(input: CheckCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appDragVerificationCheckCode.');
            }
            const localVarPath = `/api/services/app/dragVerification/CheckCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckCodeInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/dragVerification/GetDragVerificationCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DragVerificationApi - functional programming interface
 * @export
 */
export const DragVerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDragVerificationCheckCode(input: CheckCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckCodeOutput> {
            const localVarFetchArgs = DragVerificationApiFetchParamCreator(configuration).appDragVerificationCheckCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DragVerificationDto> {
            const localVarFetchArgs = DragVerificationApiFetchParamCreator(configuration).appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DragVerificationApi - factory interface
 * @export
 */
export const DragVerificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CheckCodeInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDragVerificationCheckCode(input: CheckCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DragVerificationApiFp(configuration).appDragVerificationCheckCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return DragVerificationApiFp(configuration).appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * DragVerificationApi - object-oriented interface
 * @export
 * @class DragVerificationApi
 * @extends {BaseAPI}
 */
export class DragVerificationApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DragVerificationApi
     */
    public appDragVerificationCheckCode(input: CheckCodeInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DragVerificationApiFp(this.configuration).appDragVerificationCheckCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DragVerificationApi
     */
    public appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return DragVerificationApiFp(this.configuration).appDragVerificationGetDragVerificationCode(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * FileSettingDemoApi - fetch parameter creator
 * @export
 */
export const FileSettingDemoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFileSettingDemoGet(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/fileSettingDemo/Get`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetFileSettingDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFileSettingDemoSet(input: SetFileSettingDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFileSettingDemoSet.');
            }
            const localVarPath = `/api/services/app/fileSettingDemo/Set`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetFileSettingDemoDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileSettingDemoApi - functional programming interface
 * @export
 */
export const FileSettingDemoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFileSettingDemoGet(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetFileSettingDemoDto> {
            const localVarFetchArgs = FileSettingDemoApiFetchParamCreator(configuration).appFileSettingDemoGet(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SetFileSettingDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFileSettingDemoSet(input: SetFileSettingDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileSettingDemoApiFetchParamCreator(configuration).appFileSettingDemoSet(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FileSettingDemoApi - factory interface
 * @export
 */
export const FileSettingDemoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFileSettingDemoGet(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FileSettingDemoApiFp(configuration).appFileSettingDemoGet(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SetFileSettingDemoDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFileSettingDemoSet(input: SetFileSettingDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FileSettingDemoApiFp(configuration).appFileSettingDemoSet(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * FileSettingDemoApi - object-oriented interface
 * @export
 * @class FileSettingDemoApi
 * @extends {BaseAPI}
 */
export class FileSettingDemoApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileSettingDemoApi
     */
    public appFileSettingDemoGet(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FileSettingDemoApiFp(this.configuration).appFileSettingDemoGet(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileSettingDemoApi
     */
    public appFileSettingDemoSet(input: SetFileSettingDemoDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FileSettingDemoApiFp(this.configuration).appFileSettingDemoSet(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * FriendshipApi - fetch parameter creator
 * @export
 */
export const FriendshipApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AcceptFriendshipRequestInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipAcceptFriendshipRequest(input: AcceptFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipAcceptFriendshipRequest.');
            }
            const localVarPath = `/api/services/app/friendship/AcceptFriendshipRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AcceptFriendshipRequestInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array&lt;CreateFriendshipRequestInput&gt;} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipBatchCreateFriendshipRequest(input: Array<CreateFriendshipRequestInput>, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipBatchCreateFriendshipRequest.');
            }
            const localVarPath = `/api/services/app/friendship/BatchCreateFriendshipRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;CreateFriendshipRequestInput&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BlockUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipBlockUser(input: BlockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipBlockUser.');
            }
            const localVarPath = `/api/services/app/friendship/BlockUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BlockUserInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFriendshipRequestInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipCreateFriendshipRequest(input: CreateFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipCreateFriendshipRequest.');
            }
            const localVarPath = `/api/services/app/friendship/CreateFriendshipRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateFriendshipRequestInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateFriendshipRequestByUserNameInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipCreateFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipCreateFriendshipRequestByUserName.');
            }
            const localVarPath = `/api/services/app/friendship/CreateFriendshipRequestByUserName`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateFriendshipRequestByUserNameInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PagedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipGetCreateFriendshipUserList(input: PagedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipGetCreateFriendshipUserList.');
            }
            const localVarPath = `/api/services/app/friendship/GetCreateFriendshipUserList`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PagedAndFilteredInputDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnblockUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipUnblockUser(input: UnblockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appFriendshipUnblockUser.');
            }
            const localVarPath = `/api/services/app/friendship/UnblockUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UnblockUserInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendshipApi - functional programming interface
 * @export
 */
export const FriendshipApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AcceptFriendshipRequestInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipAcceptFriendshipRequest(input: AcceptFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipAcceptFriendshipRequest(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Array&lt;CreateFriendshipRequestInput&gt;} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipBatchCreateFriendshipRequest(input: Array<CreateFriendshipRequestInput>, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FriendDto>> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipBatchCreateFriendshipRequest(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BlockUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipBlockUser(input: BlockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipBlockUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateFriendshipRequestInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipCreateFriendshipRequest(input: CreateFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FriendDto> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipCreateFriendshipRequest(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateFriendshipRequestByUserNameInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipCreateFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FriendDto> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipCreateFriendshipRequestByUserName(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PagedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipGetCreateFriendshipUserList(input: PagedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoFirendshipUserDto> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipGetCreateFriendshipUserList(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UnblockUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipUnblockUser(input: UnblockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FriendshipApiFetchParamCreator(configuration).appFriendshipUnblockUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FriendshipApi - factory interface
 * @export
 */
export const FriendshipApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AcceptFriendshipRequestInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipAcceptFriendshipRequest(input: AcceptFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipAcceptFriendshipRequest(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Array&lt;CreateFriendshipRequestInput&gt;} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipBatchCreateFriendshipRequest(input: Array<CreateFriendshipRequestInput>, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipBatchCreateFriendshipRequest(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BlockUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipBlockUser(input: BlockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipBlockUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateFriendshipRequestInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipCreateFriendshipRequest(input: CreateFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipCreateFriendshipRequest(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateFriendshipRequestByUserNameInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipCreateFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipCreateFriendshipRequestByUserName(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PagedAndFilteredInputDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipGetCreateFriendshipUserList(input: PagedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipGetCreateFriendshipUserList(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UnblockUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appFriendshipUnblockUser(input: UnblockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return FriendshipApiFp(configuration).appFriendshipUnblockUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * FriendshipApi - object-oriented interface
 * @export
 * @class FriendshipApi
 * @extends {BaseAPI}
 */
export class FriendshipApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipAcceptFriendshipRequest(input: AcceptFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipAcceptFriendshipRequest(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipBatchCreateFriendshipRequest(input: Array<CreateFriendshipRequestInput>, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipBatchCreateFriendshipRequest(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipBlockUser(input: BlockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipBlockUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipCreateFriendshipRequest(input: CreateFriendshipRequestInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipCreateFriendshipRequest(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipCreateFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipCreateFriendshipRequestByUserName(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipGetCreateFriendshipUserList(input: PagedAndFilteredInputDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipGetCreateFriendshipUserList(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipApi
     */
    public appFriendshipUnblockUser(input: UnblockUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return FriendshipApiFp(this.configuration).appFriendshipUnblockUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * GeetestApi - fetch parameter creator
 * @export
 */
export const GeetestApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GeetestCheckInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGeetestCheck(input: GeetestCheckInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appGeetestCheck.');
            }
            const localVarPath = `/api/services/app/geetest/Check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GeetestCheckInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGeetestGetCaptcha(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/geetest/GetCaptcha`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeetestApi - functional programming interface
 * @export
 */
export const GeetestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GeetestCheckInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGeetestCheck(input: GeetestCheckInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckCodeOutput> {
            const localVarFetchArgs = GeetestApiFetchParamCreator(configuration).appGeetestCheck(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGeetestGetCaptcha(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = GeetestApiFetchParamCreator(configuration).appGeetestGetCaptcha(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GeetestApi - factory interface
 * @export
 */
export const GeetestApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {GeetestCheckInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGeetestCheck(input: GeetestCheckInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return GeetestApiFp(configuration).appGeetestCheck(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGeetestGetCaptcha(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return GeetestApiFp(configuration).appGeetestGetCaptcha(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * GeetestApi - object-oriented interface
 * @export
 * @class GeetestApi
 * @extends {BaseAPI}
 */
export class GeetestApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeetestApi
     */
    public appGeetestCheck(input: GeetestCheckInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return GeetestApiFp(this.configuration).appGeetestCheck(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeetestApi
     */
    public appGeetestGetCaptcha(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return GeetestApiFp(this.configuration).appGeetestGetCaptcha(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * InterfaceExportApi - fetch parameter creator
 * @export
 */
export const InterfaceExportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/interfaceExport/GetReactDownloadUrl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InterfaceExportApi - functional programming interface
 * @export
 */
export const InterfaceExportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = InterfaceExportApiFetchParamCreator(configuration).appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InterfaceExportApi - factory interface
 * @export
 */
export const InterfaceExportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return InterfaceExportApiFp(configuration).appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * InterfaceExportApi - object-oriented interface
 * @export
 * @class InterfaceExportApi
 * @extends {BaseAPI}
 */
export class InterfaceExportApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InterfaceExportApi
     */
    public appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return InterfaceExportApiFp(this.configuration).appInterfaceExportGetReactDownloadUrl(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * MenuApi - fetch parameter creator
 * @export
 */
export const MenuApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 创建用户自定义菜单
         * @param {CreateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuCreateCustomMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appMenuCreateCustomMenu.');
            }
            const localVarPath = `/api/services/app/menu/CreateCustomMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMenuInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 创建系统菜单，开发人员使用
         * @param {CreateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuCreateSystemMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appMenuCreateSystemMenu.');
            }
            const localVarPath = `/api/services/app/menu/CreateSystemMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMenuInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 删除菜单
         * @param {DeleteMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuDeleteMenu(input: DeleteMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appMenuDeleteMenu.');
            }
            const localVarPath = `/api/services/app/menu/DeleteMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteMenuInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuGetAllMenus(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/menu/GetAllMenus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuGetUserMenus(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/menu/GetUserMenus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 移动菜单
         * @param {MoveMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuMoveMenu(input: MoveMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appMenuMoveMenu.');
            }
            const localVarPath = `/api/services/app/menu/MoveMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MoveMenuInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 更新菜单
         * @param {UpdateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuUpdateMenu(input: UpdateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appMenuUpdateMenu.');
            }
            const localVarPath = `/api/services/app/menu/UpdateMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateMenuInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenuApi - functional programming interface
 * @export
 */
export const MenuApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 创建用户自定义菜单
         * @param {CreateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuCreateCustomMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuDto> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuCreateCustomMenu(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 创建系统菜单，开发人员使用
         * @param {CreateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuCreateSystemMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuDto> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuCreateSystemMenu(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 删除菜单
         * @param {DeleteMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuDeleteMenu(input: DeleteMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuDeleteMenu(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuGetAllMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MenuDto>> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuGetAllMenus(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuGetUserMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserMenuItem>> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuGetUserMenus(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 移动菜单
         * @param {MoveMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuMoveMenu(input: MoveMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuDto> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuMoveMenu(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 更新菜单
         * @param {UpdateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuUpdateMenu(input: UpdateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MenuDto> {
            const localVarFetchArgs = MenuApiFetchParamCreator(configuration).appMenuUpdateMenu(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MenuApi - factory interface
 * @export
 */
export const MenuApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 创建用户自定义菜单
         * @param {CreateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuCreateCustomMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuCreateCustomMenu(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 创建系统菜单，开发人员使用
         * @param {CreateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuCreateSystemMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuCreateSystemMenu(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 删除菜单
         * @param {DeleteMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuDeleteMenu(input: DeleteMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuDeleteMenu(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuGetAllMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuGetAllMenus(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuGetUserMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuGetUserMenus(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 移动菜单
         * @param {MoveMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuMoveMenu(input: MoveMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuMoveMenu(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 更新菜单
         * @param {UpdateMenuInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appMenuUpdateMenu(input: UpdateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenuApiFp(configuration).appMenuUpdateMenu(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * MenuApi - object-oriented interface
 * @export
 * @class MenuApi
 * @extends {BaseAPI}
 */
export class MenuApi extends BaseAPI {
    /**
     * 
     * @summary 创建用户自定义菜单
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuCreateCustomMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuCreateCustomMenu(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 创建系统菜单，开发人员使用
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuCreateSystemMenu(input: CreateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuCreateSystemMenu(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 删除菜单
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuDeleteMenu(input: DeleteMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuDeleteMenu(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuGetAllMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuGetAllMenus(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuGetUserMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuGetUserMenus(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 移动菜单
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuMoveMenu(input: MoveMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuMoveMenu(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 更新菜单
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenuApi
     */
    public appMenuUpdateMenu(input: UpdateMenuInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenuApiFp(this.configuration).appMenuUpdateMenu(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * MenusApi - fetch parameter creator
 * @export
 */
export const MenusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取菜单及权限
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusGetMenus(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Menus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MenusApi - functional programming interface
 * @export
 */
export const MenusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取菜单及权限
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusGetMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AjaxResponse> {
            const localVarFetchArgs = MenusApiFetchParamCreator(configuration).menusGetMenus(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MenusApi - factory interface
 * @export
 */
export const MenusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 获取菜单及权限
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        menusGetMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return MenusApiFp(configuration).menusGetMenus(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * MenusApi - object-oriented interface
 * @export
 * @class MenusApi
 * @extends {BaseAPI}
 */
export class MenusApi extends BaseAPI {
    /**
     * 
     * @summary 获取菜单及权限
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MenusApi
     */
    public menusGetMenus(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return MenusApiFp(this.configuration).menusGetMenus(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * NotificationApi - fetch parameter creator
 * @export
 */
export const NotificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationGetNotificationSettings(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/notification/GetNotificationSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUserNotificationsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationGetUserNotifications(input: GetUserNotificationsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appNotificationGetUserNotifications.');
            }
            const localVarPath = `/api/services/app/notification/GetUserNotifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetUserNotificationsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/notification/SetAllNotificationsAsRead`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoGuid} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationSetNotificationAsRead(input: EntityDtoGuid, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appNotificationSetNotificationAsRead.');
            }
            const localVarPath = `/api/services/app/notification/SetNotificationAsRead`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoGuid" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateNotificationSettingsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationUpdateNotificationSettings(input: UpdateNotificationSettingsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appNotificationUpdateNotificationSettings.');
            }
            const localVarPath = `/api/services/app/notification/UpdateNotificationSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateNotificationSettingsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationGetNotificationSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetNotificationSettingsOutput> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).appNotificationGetNotificationSettings(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetUserNotificationsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationGetUserNotifications(input: GetUserNotificationsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetNotificationsOutput> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).appNotificationGetUserNotifications(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoGuid} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationSetNotificationAsRead(input: EntityDtoGuid, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).appNotificationSetNotificationAsRead(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateNotificationSettingsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationUpdateNotificationSettings(input: UpdateNotificationSettingsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotificationApiFetchParamCreator(configuration).appNotificationUpdateNotificationSettings(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationGetNotificationSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return NotificationApiFp(configuration).appNotificationGetNotificationSettings(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetUserNotificationsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationGetUserNotifications(input: GetUserNotificationsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return NotificationApiFp(configuration).appNotificationGetUserNotifications(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return NotificationApiFp(configuration).appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoGuid} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationSetNotificationAsRead(input: EntityDtoGuid, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return NotificationApiFp(configuration).appNotificationSetNotificationAsRead(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateNotificationSettingsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appNotificationUpdateNotificationSettings(input: UpdateNotificationSettingsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return NotificationApiFp(configuration).appNotificationUpdateNotificationSettings(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public appNotificationGetNotificationSettings(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return NotificationApiFp(this.configuration).appNotificationGetNotificationSettings(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public appNotificationGetUserNotifications(input: GetUserNotificationsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return NotificationApiFp(this.configuration).appNotificationGetUserNotifications(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return NotificationApiFp(this.configuration).appNotificationSetAllNotificationsAsRead(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public appNotificationSetNotificationAsRead(input: EntityDtoGuid, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return NotificationApiFp(this.configuration).appNotificationSetNotificationAsRead(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public appNotificationUpdateNotificationSettings(input: UpdateNotificationSettingsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return NotificationApiFp(this.configuration).appNotificationUpdateNotificationSettings(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * OAuthConfigurationApi - fetch parameter creator
 * @export
 */
export const OAuthConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOAuthConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/oAuthConfiguration/GetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OAuthSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOAuthConfigurationSetSetting(input: OAuthSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOAuthConfigurationSetSetting.');
            }
            const localVarPath = `/api/services/app/oAuthConfiguration/SetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OAuthSettingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthConfigurationApi - functional programming interface
 * @export
 */
export const OAuthConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOAuthConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingProperty>> {
            const localVarFetchArgs = OAuthConfigurationApiFetchParamCreator(configuration).appOAuthConfigurationGetSetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {OAuthSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOAuthConfigurationSetSetting(input: OAuthSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OAuthConfigurationApiFetchParamCreator(configuration).appOAuthConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OAuthConfigurationApi - factory interface
 * @export
 */
export const OAuthConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOAuthConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OAuthConfigurationApiFp(configuration).appOAuthConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {OAuthSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOAuthConfigurationSetSetting(input: OAuthSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OAuthConfigurationApiFp(configuration).appOAuthConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * OAuthConfigurationApi - object-oriented interface
 * @export
 * @class OAuthConfigurationApi
 * @extends {BaseAPI}
 */
export class OAuthConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary 获取设置
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthConfigurationApi
     */
    public appOAuthConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OAuthConfigurationApiFp(this.configuration).appOAuthConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthConfigurationApi
     */
    public appOAuthConfigurationSetSetting(input: OAuthSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OAuthConfigurationApiFp(this.configuration).appOAuthConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationUnitApi - fetch parameter creator
 * @export
 */
export const OrganizationUnitApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UsersToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitAddUserToOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitAddUserToOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/AddUserToOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersToOrganizationUnitInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 创建组织机构
         * @param {CreateOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitCreateOrganizationUnit(input: CreateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitCreateOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/CreateOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOrganizationUnitInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 删除组织机构
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitDeleteOrganizationUnit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitDeleteOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/DeleteOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取可加入某组织单元的所有人员
         * @param {GetOrganizationUnitJoinableUserListInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnitJoinableUserList(input: GetOrganizationUnitJoinableUserListInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitGetOrganizationUnitJoinableUserList.');
            }
            const localVarPath = `/api/services/app/organizationUnit/GetOrganizationUnitJoinableUserList`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetOrganizationUnitJoinableUserListInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取组织机构下的所有人员
         * @param {GetOrganizationUnitUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnitUsers(input: GetOrganizationUnitUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitGetOrganizationUnitUsers.');
            }
            const localVarPath = `/api/services/app/organizationUnit/GetOrganizationUnitUsers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetOrganizationUnitUsersInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取组织机构树
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/organizationUnit/GetOrganizationUnits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserIdInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetUserOrganizationUnits(input: UserIdInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitGetUserOrganizationUnits.');
            }
            const localVarPath = `/api/services/app/organizationUnit/GetUserOrganizationUnits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserIdInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 用户是否属于组织机构
         * @param {UserToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitIsInOrganizationUnit(input: UserToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitIsInOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/IsInOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserToOrganizationUnitInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 移动组织机构
         * @param {MoveOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitMoveOrganizationUnit(input: MoveOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitMoveOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/MoveOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MoveOrganizationUnitInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitRemoveAllOrganizationUnit(userId: number, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling appOrganizationUnitRemoveAllOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/RemoveAllOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UsersToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitRemoveUserFromOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitRemoveUserFromOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/RemoveUserFromOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersToOrganizationUnitInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 修改组织机构信息
         * @param {UpdateOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitUpdateOrganizationUnit(input: UpdateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appOrganizationUnitUpdateOrganizationUnit.');
            }
            const localVarPath = `/api/services/app/organizationUnit/UpdateOrganizationUnit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOrganizationUnitInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationUnitApi - functional programming interface
 * @export
 */
export const OrganizationUnitApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UsersToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitAddUserToOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitAddUserToOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 创建组织机构
         * @param {CreateOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitCreateOrganizationUnit(input: CreateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationUnitDto> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitCreateOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 删除组织机构
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitDeleteOrganizationUnit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitDeleteOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取可加入某组织单元的所有人员
         * @param {GetOrganizationUnitJoinableUserListInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnitJoinableUserList(input: GetOrganizationUnitJoinableUserListInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoOrganizationUnitUserDto> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitGetOrganizationUnitJoinableUserList(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取组织机构下的所有人员
         * @param {GetOrganizationUnitUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnitUsers(input: GetOrganizationUnitUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoOrganizationUnitUserListDto> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitGetOrganizationUnitUsers(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取组织机构树
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResultDtoOrganizationUnitDto> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UserIdInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetUserOrganizationUnits(input: UserIdInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitGetUserOrganizationUnits(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 用户是否属于组织机构
         * @param {UserToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitIsInOrganizationUnit(input: UserToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitIsInOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 移动组织机构
         * @param {MoveOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitMoveOrganizationUnit(input: MoveOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationUnitDto> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitMoveOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitRemoveAllOrganizationUnit(userId: number, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitRemoveAllOrganizationUnit(userId, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UsersToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitRemoveUserFromOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitRemoveUserFromOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 修改组织机构信息
         * @param {UpdateOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitUpdateOrganizationUnit(input: UpdateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationUnitDto> {
            const localVarFetchArgs = OrganizationUnitApiFetchParamCreator(configuration).appOrganizationUnitUpdateOrganizationUnit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationUnitApi - factory interface
 * @export
 */
export const OrganizationUnitApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {UsersToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitAddUserToOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitAddUserToOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 创建组织机构
         * @param {CreateOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitCreateOrganizationUnit(input: CreateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitCreateOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 删除组织机构
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitDeleteOrganizationUnit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitDeleteOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取可加入某组织单元的所有人员
         * @param {GetOrganizationUnitJoinableUserListInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnitJoinableUserList(input: GetOrganizationUnitJoinableUserListInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitGetOrganizationUnitJoinableUserList(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取组织机构下的所有人员
         * @param {GetOrganizationUnitUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnitUsers(input: GetOrganizationUnitUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitGetOrganizationUnitUsers(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取组织机构树
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UserIdInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitGetUserOrganizationUnits(input: UserIdInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitGetUserOrganizationUnits(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 用户是否属于组织机构
         * @param {UserToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitIsInOrganizationUnit(input: UserToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitIsInOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 移动组织机构
         * @param {MoveOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitMoveOrganizationUnit(input: MoveOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitMoveOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitRemoveAllOrganizationUnit(userId: number, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitRemoveAllOrganizationUnit(userId, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UsersToOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitRemoveUserFromOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitRemoveUserFromOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 修改组织机构信息
         * @param {UpdateOrganizationUnitInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appOrganizationUnitUpdateOrganizationUnit(input: UpdateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return OrganizationUnitApiFp(configuration).appOrganizationUnitUpdateOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationUnitApi - object-oriented interface
 * @export
 * @class OrganizationUnitApi
 * @extends {BaseAPI}
 */
export class OrganizationUnitApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitAddUserToOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitAddUserToOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 创建组织机构
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitCreateOrganizationUnit(input: CreateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitCreateOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 删除组织机构
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitDeleteOrganizationUnit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitDeleteOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取可加入某组织单元的所有人员
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitGetOrganizationUnitJoinableUserList(input: GetOrganizationUnitJoinableUserListInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitGetOrganizationUnitJoinableUserList(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取组织机构下的所有人员
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitGetOrganizationUnitUsers(input: GetOrganizationUnitUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitGetOrganizationUnitUsers(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取组织机构树
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitGetOrganizationUnits(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitGetUserOrganizationUnits(input: UserIdInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitGetUserOrganizationUnits(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 用户是否属于组织机构
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitIsInOrganizationUnit(input: UserToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitIsInOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 移动组织机构
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitMoveOrganizationUnit(input: MoveOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitMoveOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} userId 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitRemoveAllOrganizationUnit(userId: number, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitRemoveAllOrganizationUnit(userId, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitRemoveUserFromOrganizationUnit(input: UsersToOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitRemoveUserFromOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 修改组织机构信息
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationUnitApi
     */
    public appOrganizationUnitUpdateOrganizationUnit(input: UpdateOrganizationUnitInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return OrganizationUnitApiFp(this.configuration).appOrganizationUnitUpdateOrganizationUnit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * PermissionApi - fetch parameter creator
 * @export
 */
export const PermissionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetAllPermissionTree(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/permission/GetAllPermissionTree`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetAllPermissions(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/permission/GetAllPermissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetUserPermissions(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/permission/GetUserPermissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetAllPermissionTree(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PermissionDto>> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).appPermissionGetAllPermissionTree(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetAllPermissions(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResultDtoFlatPermissionWithLevelDto> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).appPermissionGetAllPermissions(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetUserPermissions(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = PermissionApiFetchParamCreator(configuration).appPermissionGetUserPermissions(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetAllPermissionTree(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return PermissionApiFp(configuration).appPermissionGetAllPermissionTree(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetAllPermissions(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return PermissionApiFp(configuration).appPermissionGetAllPermissions(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPermissionGetUserPermissions(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return PermissionApiFp(configuration).appPermissionGetUserPermissions(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public appPermissionGetAllPermissionTree(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return PermissionApiFp(this.configuration).appPermissionGetAllPermissionTree(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public appPermissionGetAllPermissions(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return PermissionApiFp(this.configuration).appPermissionGetAllPermissions(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public appPermissionGetUserPermissions(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return PermissionApiFp(this.configuration).appPermissionGetUserPermissions(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * ProfileApi - fetch parameter creator
 * @export
 */
export const ProfileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangePasswordInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileChangePassword(input: ChangePasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appProfileChangePassword.');
            }
            const localVarPath = `/api/services/app/profile/ChangePassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangePasswordInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangeUserPasswordInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileChangeUserPassword(input: ChangeUserPasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appProfileChangeUserPassword.');
            }
            const localVarPath = `/api/services/app/profile/ChangeUserPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeUserPasswordInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/profile/GetCurrentUserProfileForEdit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/profile/GetPasswordComplexitySetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileResetUserPassword(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appProfileResetUserPassword.');
            }
            const localVarPath = `/api/services/app/profile/ResetUserPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CurrentUserProfileEditDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileUpdateCurrentUserProfile(input: CurrentUserProfileEditDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appProfileUpdateCurrentUserProfile.');
            }
            const localVarPath = `/api/services/app/profile/UpdateCurrentUserProfile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CurrentUserProfileEditDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfilePictureInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileUpdateProfilePicture(input: UpdateProfilePictureInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appProfileUpdateProfilePicture.');
            }
            const localVarPath = `/api/services/app/profile/UpdateProfilePicture`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateProfilePictureInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangePasswordInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileChangePassword(input: ChangePasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileChangePassword(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ChangeUserPasswordInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileChangeUserPassword(input: ChangeUserPasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileChangeUserPassword(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CurrentUserProfileEditDto> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPasswordComplexitySettingOutput> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileResetUserPassword(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileResetUserPassword(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CurrentUserProfileEditDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileUpdateCurrentUserProfile(input: CurrentUserProfileEditDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileUpdateCurrentUserProfile(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateProfilePictureInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileUpdateProfilePicture(input: UpdateProfilePictureInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).appProfileUpdateProfilePicture(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ChangePasswordInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileChangePassword(input: ChangePasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileChangePassword(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ChangeUserPasswordInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileChangeUserPassword(input: ChangeUserPasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileChangeUserPassword(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileResetUserPassword(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileResetUserPassword(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CurrentUserProfileEditDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileUpdateCurrentUserProfile(input: CurrentUserProfileEditDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileUpdateCurrentUserProfile(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateProfilePictureInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appProfileUpdateProfilePicture(input: UpdateProfilePictureInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return ProfileApiFp(configuration).appProfileUpdateProfilePicture(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileChangePassword(input: ChangePasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileChangePassword(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileChangeUserPassword(input: ChangeUserPasswordInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileChangeUserPassword(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileGetCurrentUserProfileForEdit(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileGetPasswordComplexitySetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileResetUserPassword(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileResetUserPassword(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileUpdateCurrentUserProfile(input: CurrentUserProfileEditDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileUpdateCurrentUserProfile(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public appProfileUpdateProfilePicture(input: UpdateProfilePictureInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return ProfileApiFp(this.configuration).appProfileUpdateProfilePicture(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * PushConfigurationApi - fetch parameter creator
 * @export
 */
export const PushConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPushConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/pushConfiguration/GetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PushSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPushConfigurationSetSetting(input: PushSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appPushConfigurationSetSetting.');
            }
            const localVarPath = `/api/services/app/pushConfiguration/SetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PushSettingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushConfigurationApi - functional programming interface
 * @export
 */
export const PushConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPushConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingProperty>> {
            const localVarFetchArgs = PushConfigurationApiFetchParamCreator(configuration).appPushConfigurationGetSetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PushSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPushConfigurationSetSetting(input: PushSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PushConfigurationApiFetchParamCreator(configuration).appPushConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PushConfigurationApi - factory interface
 * @export
 */
export const PushConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPushConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return PushConfigurationApiFp(configuration).appPushConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PushSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appPushConfigurationSetSetting(input: PushSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return PushConfigurationApiFp(configuration).appPushConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * PushConfigurationApi - object-oriented interface
 * @export
 * @class PushConfigurationApi
 * @extends {BaseAPI}
 */
export class PushConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary 获取设置
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushConfigurationApi
     */
    public appPushConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return PushConfigurationApiFp(this.configuration).appPushConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushConfigurationApi
     */
    public appPushConfigurationSetSetting(input: PushSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return PushConfigurationApiFp(this.configuration).appPushConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * RegisterApi - fetch parameter creator
 * @export
 */
export const RegisterApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RegisterInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegister(input: RegisterInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRegisterRegister.');
            }
            const localVarPath = `/api/services/app/register/Register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterByEmailInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterByEmail(input: RegisterByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRegisterRegisterByEmail.');
            }
            const localVarPath = `/api/services/app/register/RegisterByEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterByEmailInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterByPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterByPhoneNumber(input: RegisterByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRegisterRegisterByPhoneNumber.');
            }
            const localVarPath = `/api/services/app/register/RegisterByPhoneNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterByPhoneNumberInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterOnlyPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterOnlyPhoneNumber(input: RegisterOnlyPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRegisterRegisterOnlyPhoneNumber.');
            }
            const localVarPath = `/api/services/app/register/RegisterOnlyPhoneNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterOnlyPhoneNumberInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRegisterSendEmailCode.');
            }
            const localVarPath = `/api/services/app/register/SendEmailCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendConfirmEmailByCaptchaInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRegisterSendPhoneNumberCode.');
            }
            const localVarPath = `/api/services/app/register/SendPhoneNumberCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PhoneWithCaptchaInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegisterApi - functional programming interface
 * @export
 */
export const RegisterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RegisterInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegister(input: RegisterInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterOutput> {
            const localVarFetchArgs = RegisterApiFetchParamCreator(configuration).appRegisterRegister(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RegisterByEmailInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterByEmail(input: RegisterByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterOutput> {
            const localVarFetchArgs = RegisterApiFetchParamCreator(configuration).appRegisterRegisterByEmail(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RegisterByPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterByPhoneNumber(input: RegisterByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterOutput> {
            const localVarFetchArgs = RegisterApiFetchParamCreator(configuration).appRegisterRegisterByPhoneNumber(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RegisterOnlyPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterOnlyPhoneNumber(input: RegisterOnlyPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterOutput> {
            const localVarFetchArgs = RegisterApiFetchParamCreator(configuration).appRegisterRegisterOnlyPhoneNumber(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RegisterApiFetchParamCreator(configuration).appRegisterSendEmailCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RegisterApiFetchParamCreator(configuration).appRegisterSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegisterApi - factory interface
 * @export
 */
export const RegisterApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {RegisterInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegister(input: RegisterInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RegisterApiFp(configuration).appRegisterRegister(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RegisterByEmailInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterByEmail(input: RegisterByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RegisterApiFp(configuration).appRegisterRegisterByEmail(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RegisterByPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterByPhoneNumber(input: RegisterByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RegisterApiFp(configuration).appRegisterRegisterByPhoneNumber(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RegisterOnlyPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterRegisterOnlyPhoneNumber(input: RegisterOnlyPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RegisterApiFp(configuration).appRegisterRegisterOnlyPhoneNumber(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RegisterApiFp(configuration).appRegisterSendEmailCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRegisterSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RegisterApiFp(configuration).appRegisterSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * RegisterApi - object-oriented interface
 * @export
 * @class RegisterApi
 * @extends {BaseAPI}
 */
export class RegisterApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public appRegisterRegister(input: RegisterInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RegisterApiFp(this.configuration).appRegisterRegister(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public appRegisterRegisterByEmail(input: RegisterByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RegisterApiFp(this.configuration).appRegisterRegisterByEmail(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public appRegisterRegisterByPhoneNumber(input: RegisterByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RegisterApiFp(this.configuration).appRegisterRegisterByPhoneNumber(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public appRegisterRegisterOnlyPhoneNumber(input: RegisterOnlyPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RegisterApiFp(this.configuration).appRegisterRegisterOnlyPhoneNumber(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public appRegisterSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RegisterApiFp(this.configuration).appRegisterSendEmailCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public appRegisterSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RegisterApiFp(this.configuration).appRegisterSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * RestPasswordApi - fetch parameter creator
 * @export
 */
export const RestPasswordApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ResetPasswordByEmailInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordResetPasswordByEmail(input: ResetPasswordByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRestPasswordResetPasswordByEmail.');
            }
            const localVarPath = `/api/services/app/restPassword/ResetPasswordByEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetPasswordByEmailInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPasswordByPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordResetPasswordByPhoneNumber(input: ResetPasswordByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRestPasswordResetPasswordByPhoneNumber.');
            }
            const localVarPath = `/api/services/app/restPassword/ResetPasswordByPhoneNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetPasswordByPhoneNumberInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRestPasswordSendEmailCode.');
            }
            const localVarPath = `/api/services/app/restPassword/SendEmailCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendConfirmEmailByCaptchaInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRestPasswordSendPhoneNumberCode.');
            }
            const localVarPath = `/api/services/app/restPassword/SendPhoneNumberCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PhoneWithCaptchaInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestPasswordApi - functional programming interface
 * @export
 */
export const RestPasswordApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ResetPasswordByEmailInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordResetPasswordByEmail(input: ResetPasswordByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RestPasswordApiFetchParamCreator(configuration).appRestPasswordResetPasswordByEmail(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ResetPasswordByPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordResetPasswordByPhoneNumber(input: ResetPasswordByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RestPasswordApiFetchParamCreator(configuration).appRestPasswordResetPasswordByPhoneNumber(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RestPasswordApiFetchParamCreator(configuration).appRestPasswordSendEmailCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RestPasswordApiFetchParamCreator(configuration).appRestPasswordSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RestPasswordApi - factory interface
 * @export
 */
export const RestPasswordApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ResetPasswordByEmailInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordResetPasswordByEmail(input: ResetPasswordByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RestPasswordApiFp(configuration).appRestPasswordResetPasswordByEmail(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ResetPasswordByPhoneNumberInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordResetPasswordByPhoneNumber(input: ResetPasswordByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RestPasswordApiFp(configuration).appRestPasswordResetPasswordByPhoneNumber(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SendConfirmEmailByCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RestPasswordApiFp(configuration).appRestPasswordSendEmailCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PhoneWithCaptchaInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRestPasswordSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RestPasswordApiFp(configuration).appRestPasswordSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * RestPasswordApi - object-oriented interface
 * @export
 * @class RestPasswordApi
 * @extends {BaseAPI}
 */
export class RestPasswordApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestPasswordApi
     */
    public appRestPasswordResetPasswordByEmail(input: ResetPasswordByEmailInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RestPasswordApiFp(this.configuration).appRestPasswordResetPasswordByEmail(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestPasswordApi
     */
    public appRestPasswordResetPasswordByPhoneNumber(input: ResetPasswordByPhoneNumberInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RestPasswordApiFp(this.configuration).appRestPasswordResetPasswordByPhoneNumber(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestPasswordApi
     */
    public appRestPasswordSendEmailCode(input: SendConfirmEmailByCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RestPasswordApiFp(this.configuration).appRestPasswordSendEmailCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestPasswordApi
     */
    public appRestPasswordSendPhoneNumberCode(input: PhoneWithCaptchaInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RestPasswordApiFp(this.configuration).appRestPasswordSendPhoneNumberCode(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * RoleApi - fetch parameter creator
 * @export
 */
export const RoleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 创建或修改角色
         * @param {CreateOrUpdateRoleInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleCreateOrUpdateRole(input: CreateOrUpdateRoleInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRoleCreateOrUpdateRole.');
            }
            const localVarPath = `/api/services/app/role/CreateOrUpdateRole`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOrUpdateRoleInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 删除角色
         * @param {EntityDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleDeleteRole(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRoleDeleteRole.');
            }
            const localVarPath = `/api/services/app/role/DeleteRole`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取编辑时需要的角色信息
         * @param {NullableIdDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleGetRoleForEdit(input: NullableIdDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRoleGetRoleForEdit.');
            }
            const localVarPath = `/api/services/app/role/GetRoleForEdit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NullableIdDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取角色列表
         * @param {GetRolesInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleGetRoles(input: GetRolesInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appRoleGetRoles.');
            }
            const localVarPath = `/api/services/app/role/GetRoles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetRolesInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 创建或修改角色
         * @param {CreateOrUpdateRoleInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleCreateOrUpdateRole(input: CreateOrUpdateRoleInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RoleApiFetchParamCreator(configuration).appRoleCreateOrUpdateRole(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 删除角色
         * @param {EntityDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleDeleteRole(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RoleApiFetchParamCreator(configuration).appRoleDeleteRole(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取编辑时需要的角色信息
         * @param {NullableIdDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleGetRoleForEdit(input: NullableIdDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetRoleForEditOutput> {
            const localVarFetchArgs = RoleApiFetchParamCreator(configuration).appRoleGetRoleForEdit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取角色列表
         * @param {GetRolesInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleGetRoles(input: GetRolesInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResultDtoRoleListDto> {
            const localVarFetchArgs = RoleApiFetchParamCreator(configuration).appRoleGetRoles(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 创建或修改角色
         * @param {CreateOrUpdateRoleInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleCreateOrUpdateRole(input: CreateOrUpdateRoleInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RoleApiFp(configuration).appRoleCreateOrUpdateRole(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 删除角色
         * @param {EntityDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleDeleteRole(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RoleApiFp(configuration).appRoleDeleteRole(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取编辑时需要的角色信息
         * @param {NullableIdDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleGetRoleForEdit(input: NullableIdDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RoleApiFp(configuration).appRoleGetRoleForEdit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取角色列表
         * @param {GetRolesInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appRoleGetRoles(input: GetRolesInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return RoleApiFp(configuration).appRoleGetRoles(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     * 
     * @summary 创建或修改角色
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public appRoleCreateOrUpdateRole(input: CreateOrUpdateRoleInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RoleApiFp(this.configuration).appRoleCreateOrUpdateRole(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 删除角色
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public appRoleDeleteRole(input: EntityDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RoleApiFp(this.configuration).appRoleDeleteRole(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取编辑时需要的角色信息
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public appRoleGetRoleForEdit(input: NullableIdDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RoleApiFp(this.configuration).appRoleGetRoleForEdit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取角色列表
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public appRoleGetRoles(input: GetRolesInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return RoleApiFp(this.configuration).appRoleGetRoles(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * SMSLoginApi - fetch parameter creator
 * @export
 */
export const SMSLoginApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginForSmsCode} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sMSLoginAuthenticate(input: LoginForSmsCode, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling sMSLoginAuthenticate.');
            }
            const localVarPath = `/api/SMSLogin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginForSmsCode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SMSLoginApi - functional programming interface
 * @export
 */
export const SMSLoginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginForSmsCode} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sMSLoginAuthenticate(input: LoginForSmsCode, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AjaxResponse> {
            const localVarFetchArgs = SMSLoginApiFetchParamCreator(configuration).sMSLoginAuthenticate(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SMSLoginApi - factory interface
 * @export
 */
export const SMSLoginApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {LoginForSmsCode} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sMSLoginAuthenticate(input: LoginForSmsCode, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return SMSLoginApiFp(configuration).sMSLoginAuthenticate(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * SMSLoginApi - object-oriented interface
 * @export
 * @class SMSLoginApi
 * @extends {BaseAPI}
 */
export class SMSLoginApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSLoginApi
     */
    public sMSLoginAuthenticate(input: LoginForSmsCode, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return SMSLoginApiFp(this.configuration).sMSLoginAuthenticate(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * SecurityConfigurationApi - fetch parameter creator
 * @export
 */
export const SecurityConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSecurityConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/securityConfiguration/GetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SecuritySettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSecurityConfigurationSetSetting(input: SecuritySettingDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appSecurityConfigurationSetSetting.');
            }
            const localVarPath = `/api/services/app/securityConfiguration/SetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecuritySettingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityConfigurationApi - functional programming interface
 * @export
 */
export const SecurityConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSecurityConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingProperty>> {
            const localVarFetchArgs = SecurityConfigurationApiFetchParamCreator(configuration).appSecurityConfigurationGetSetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SecuritySettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSecurityConfigurationSetSetting(input: SecuritySettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SecurityConfigurationApiFetchParamCreator(configuration).appSecurityConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecurityConfigurationApi - factory interface
 * @export
 */
export const SecurityConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSecurityConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return SecurityConfigurationApiFp(configuration).appSecurityConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SecuritySettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSecurityConfigurationSetSetting(input: SecuritySettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return SecurityConfigurationApiFp(configuration).appSecurityConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * SecurityConfigurationApi - object-oriented interface
 * @export
 * @class SecurityConfigurationApi
 * @extends {BaseAPI}
 */
export class SecurityConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary 获取设置
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityConfigurationApi
     */
    public appSecurityConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return SecurityConfigurationApiFp(this.configuration).appSecurityConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityConfigurationApi
     */
    public appSecurityConfigurationSetSetting(input: SecuritySettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return SecurityConfigurationApiFp(this.configuration).appSecurityConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * SessionApi - fetch parameter creator
 * @export
 */
export const SessionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSessionGetCurrentLoginInformations(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/session/GetCurrentLoginInformations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSessionGetCurrentLoginInformations(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCurrentLoginInformationsOutput> {
            const localVarFetchArgs = SessionApiFetchParamCreator(configuration).appSessionGetCurrentLoginInformations(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSessionGetCurrentLoginInformations(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return SessionApiFp(configuration).appSessionGetCurrentLoginInformations(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public appSessionGetCurrentLoginInformations(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return SessionApiFp(this.configuration).appSessionGetCurrentLoginInformations(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * SystemConfigurationApi - fetch parameter creator
 * @export
 */
export const SystemConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSystemConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/systemConfiguration/GetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SystemSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSystemConfigurationSetSetting(input: SystemSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appSystemConfigurationSetSetting.');
            }
            const localVarPath = `/api/services/app/systemConfiguration/SetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SystemSettingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemConfigurationApi - functional programming interface
 * @export
 */
export const SystemConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSystemConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingProperty>> {
            const localVarFetchArgs = SystemConfigurationApiFetchParamCreator(configuration).appSystemConfigurationGetSetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SystemSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSystemConfigurationSetSetting(input: SystemSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SystemConfigurationApiFetchParamCreator(configuration).appSystemConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SystemConfigurationApi - factory interface
 * @export
 */
export const SystemConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSystemConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return SystemConfigurationApiFp(configuration).appSystemConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SystemSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appSystemConfigurationSetSetting(input: SystemSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return SystemConfigurationApiFp(configuration).appSystemConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * SystemConfigurationApi - object-oriented interface
 * @export
 * @class SystemConfigurationApi
 * @extends {BaseAPI}
 */
export class SystemConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary 获取设置
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigurationApi
     */
    public appSystemConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return SystemConfigurationApiFp(this.configuration).appSystemConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemConfigurationApi
     */
    public appSystemConfigurationSetSetting(input: SystemSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return SystemConfigurationApiFp(this.configuration).appSystemConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * TypeScriptApi - fetch parameter creator
 * @export
 */
export const TypeScriptApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {boolean} [isCompleteService] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeScriptGet(X_XSRF_TOKEN?: string, authorization?: string, isCompleteService?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/api/TypeScript`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isCompleteService !== undefined) {
                localVarQueryParameter['isCompleteService'] = isCompleteService;
            }

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TypeScriptApi - functional programming interface
 * @export
 */
export const TypeScriptApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {boolean} [isCompleteService] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeScriptGet(X_XSRF_TOKEN?: string, authorization?: string, isCompleteService?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = TypeScriptApiFetchParamCreator(configuration).typeScriptGet(X_XSRF_TOKEN, authorization, isCompleteService, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TypeScriptApi - factory interface
 * @export
 */
export const TypeScriptApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {boolean} [isCompleteService] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeScriptGet(X_XSRF_TOKEN?: string, authorization?: string, isCompleteService?: boolean, options?: any) {
            return TypeScriptApiFp(configuration).typeScriptGet(X_XSRF_TOKEN, authorization, isCompleteService, options)(fetch, basePath);
        },
    };
};

/**
 * TypeScriptApi - object-oriented interface
 * @export
 * @class TypeScriptApi
 * @extends {BaseAPI}
 */
export class TypeScriptApi extends BaseAPI {
    /**
     * 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {} [isCompleteService] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TypeScriptApi
     */
    public typeScriptGet(X_XSRF_TOKEN?: string, authorization?: string, isCompleteService?: boolean, options?: any) {
        return TypeScriptApiFp(this.configuration).typeScriptGet(X_XSRF_TOKEN, authorization, isCompleteService, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BatchActiveUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchActiveUser(input: BatchActiveUserInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserBatchActiveUser.');
            }
            const localVarPath = `/api/services/app/user/BatchActiveUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BatchActiveUserInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArrayDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchDeleteUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserBatchDeleteUser.');
            }
            const localVarPath = `/api/services/app/user/BatchDeleteUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArrayDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArrayDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchUnlockUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserBatchUnlockUser.');
            }
            const localVarPath = `/api/services/app/user/BatchUnlockUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArrayDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 创建或编辑用户，Id为空时创建，否则编辑
         * @param {CreateOrUpdateUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserCreateOrUpdateUser(input: CreateOrUpdateUserInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserCreateOrUpdateUser.');
            }
            const localVarPath = `/api/services/app/user/CreateOrUpdateUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOrUpdateUserInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserDeleteUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserDeleteUser.');
            }
            const localVarPath = `/api/services/app/user/DeleteUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取全部的角色
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetRoles(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/user/GetRoles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取编辑时需要的单个用户信息
         * @param {NullableIdDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUserForEdit(input: NullableIdDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserGetUserForEdit.');
            }
            const localVarPath = `/api/services/app/user/GetUserForEdit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NullableIdDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取编辑时需要的用户权限
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUserPermissionsForEdit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserGetUserPermissionsForEdit.');
            }
            const localVarPath = `/api/services/app/user/GetUserPermissionsForEdit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 获取用户列表
         * @param {GetUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUsers(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserGetUsers.');
            }
            const localVarPath = `/api/services/app/user/GetUsers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetUsersInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUsersToExcel(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserGetUsersToExcel.');
            }
            const localVarPath = `/api/services/app/user/GetUsersToExcel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetUsersInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 重置用户权限
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserResetUserSpecificPermissions(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserResetUserSpecificPermissions.');
            }
            const localVarPath = `/api/services/app/user/ResetUserSpecificPermissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserToggleActiveStatus(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserToggleActiveStatus.');
            }
            const localVarPath = `/api/services/app/user/ToggleActiveStatus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUnlockUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserUnlockUser.');
            }
            const localVarPath = `/api/services/app/user/UnlockUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EntityDtoInt64" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateCurrentUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUpdateCurrentUser(input: UpdateCurrentUserInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserUpdateCurrentUser.');
            }
            const localVarPath = `/api/services/app/user/UpdateCurrentUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCurrentUserInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 修改用户权限
         * @param {UpdateUserPermissionsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUpdateUserPermissions(input: UpdateUserPermissionsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserUpdateUserPermissions.');
            }
            const localVarPath = `/api/services/app/user/UpdateUserPermissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserPermissionsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BatchActiveUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchActiveUser(input: BatchActiveUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserBatchActiveUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ArrayDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchDeleteUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserBatchDeleteUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ArrayDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchUnlockUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserBatchUnlockUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 创建或编辑用户，Id为空时创建，否则编辑
         * @param {CreateOrUpdateUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserCreateOrUpdateUser(input: CreateOrUpdateUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserCreateOrUpdateUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserDeleteUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserDeleteUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取全部的角色
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetRoles(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResultDtoRoleDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserGetRoles(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取编辑时需要的单个用户信息
         * @param {NullableIdDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUserForEdit(input: NullableIdDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserForEditOutput> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserGetUserForEdit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取编辑时需要的用户权限
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUserPermissionsForEdit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserPermissionsForEditOutput> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserGetUserPermissionsForEdit(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 获取用户列表
         * @param {GetUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUsers(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoUserListDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserGetUsers(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUsersToExcel(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserGetUsersToExcel(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 重置用户权限
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserResetUserSpecificPermissions(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserResetUserSpecificPermissions(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserToggleActiveStatus(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserToggleActiveStatus(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUnlockUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserUnlockUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateCurrentUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUpdateCurrentUser(input: UpdateCurrentUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserUpdateCurrentUser(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary 修改用户权限
         * @param {UpdateUserPermissionsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUpdateUserPermissions(input: UpdateUserPermissionsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).appUserUpdateUserPermissions(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {BatchActiveUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchActiveUser(input: BatchActiveUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserBatchActiveUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ArrayDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchDeleteUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserBatchDeleteUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ArrayDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserBatchUnlockUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserBatchUnlockUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 创建或编辑用户，Id为空时创建，否则编辑
         * @param {CreateOrUpdateUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserCreateOrUpdateUser(input: CreateOrUpdateUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserCreateOrUpdateUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserDeleteUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserDeleteUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取全部的角色
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetRoles(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserGetRoles(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取编辑时需要的单个用户信息
         * @param {NullableIdDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUserForEdit(input: NullableIdDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserGetUserForEdit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取编辑时需要的用户权限
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUserPermissionsForEdit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserGetUserPermissionsForEdit(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 获取用户列表
         * @param {GetUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUsers(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserGetUsers(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetUsersInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserGetUsersToExcel(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserGetUsersToExcel(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 重置用户权限
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserResetUserSpecificPermissions(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserResetUserSpecificPermissions(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserToggleActiveStatus(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserToggleActiveStatus(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {EntityDtoInt64} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUnlockUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserUnlockUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateCurrentUserInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUpdateCurrentUser(input: UpdateCurrentUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserUpdateCurrentUser(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @summary 修改用户权限
         * @param {UpdateUserPermissionsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserUpdateUserPermissions(input: UpdateUserPermissionsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserApiFp(configuration).appUserUpdateUserPermissions(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserBatchActiveUser(input: BatchActiveUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserBatchActiveUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserBatchDeleteUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserBatchDeleteUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserBatchUnlockUser(input: ArrayDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserBatchUnlockUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 创建或编辑用户，Id为空时创建，否则编辑
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserCreateOrUpdateUser(input: CreateOrUpdateUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserCreateOrUpdateUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserDeleteUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserDeleteUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取全部的角色
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserGetRoles(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserGetRoles(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取编辑时需要的单个用户信息
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserGetUserForEdit(input: NullableIdDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserGetUserForEdit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取编辑时需要的用户权限
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserGetUserPermissionsForEdit(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserGetUserPermissionsForEdit(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 获取用户列表
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserGetUsers(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserGetUsers(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserGetUsersToExcel(input: GetUsersInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserGetUsersToExcel(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 重置用户权限
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserResetUserSpecificPermissions(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserResetUserSpecificPermissions(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserToggleActiveStatus(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserToggleActiveStatus(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserUnlockUser(input: EntityDtoInt64, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserUnlockUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserUpdateCurrentUser(input: UpdateCurrentUserInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserUpdateCurrentUser(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary 修改用户权限
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appUserUpdateUserPermissions(input: UpdateUserPermissionsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserApiFp(this.configuration).appUserUpdateUserPermissions(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * UserLoginApi - fetch parameter creator
 * @export
 */
export const UserLoginApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetUserLoginsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserLoginGetRecentUserLoginAttempts(input: GetUserLoginsInput, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserLoginGetRecentUserLoginAttempts.');
            }
            const localVarPath = `/api/services/app/userLogin/GetRecentUserLoginAttempts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetUserLoginsInput" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserLoginApi - functional programming interface
 * @export
 */
export const UserLoginApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetUserLoginsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserLoginGetRecentUserLoginAttempts(input: GetUserLoginsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResultDtoUserLoginAttemptDto> {
            const localVarFetchArgs = UserLoginApiFetchParamCreator(configuration).appUserLoginGetRecentUserLoginAttempts(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserLoginApi - factory interface
 * @export
 */
export const UserLoginApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {GetUserLoginsInput} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserLoginGetRecentUserLoginAttempts(input: GetUserLoginsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserLoginApiFp(configuration).appUserLoginGetRecentUserLoginAttempts(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * UserLoginApi - object-oriented interface
 * @export
 * @class UserLoginApi
 * @extends {BaseAPI}
 */
export class UserLoginApi extends BaseAPI {
    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginApi
     */
    public appUserLoginGetRecentUserLoginAttempts(input: GetUserLoginsInput, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserLoginApiFp(this.configuration).appUserLoginGetRecentUserLoginAttempts(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

/**
 * UserManagementConfigurationApi - fetch parameter creator
 * @export
 */
export const UserManagementConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserManagementConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/services/app/userManagementConfiguration/GetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserManagementSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserManagementConfigurationSetSetting(input: UserManagementSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options: any = {}): FetchArgs {
            // verify required parameter 'input' is not null or undefined
            if (input === null || input === undefined) {
                throw new RequiredError('input','Required parameter input was null or undefined when calling appUserManagementConfigurationSetSetting.');
            }
            const localVarPath = `/api/services/app/userManagementConfiguration/SetSetting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (X_XSRF_TOKEN !== undefined && X_XSRF_TOKEN !== null) {
                localVarHeaderParameter['X-XSRF-TOKEN'] = String(X_XSRF_TOKEN);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserManagementSettingDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(input || {}) : (input || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementConfigurationApi - functional programming interface
 * @export
 */
export const UserManagementConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserManagementConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingProperty>> {
            const localVarFetchArgs = UserManagementConfigurationApiFetchParamCreator(configuration).appUserManagementConfigurationGetSetting(X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UserManagementSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserManagementConfigurationSetSetting(input: UserManagementSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserManagementConfigurationApiFetchParamCreator(configuration).appUserManagementConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserManagementConfigurationApi - factory interface
 * @export
 */
export const UserManagementConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary 获取设置
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserManagementConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserManagementConfigurationApiFp(configuration).appUserManagementConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UserManagementSettingDto} input 
         * @param {string} [X_XSRF_TOKEN] XSRF-TOKEN
         * @param {string} [authorization] token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appUserManagementConfigurationSetSetting(input: UserManagementSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
            return UserManagementConfigurationApiFp(configuration).appUserManagementConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(fetch, basePath);
        },
    };
};

/**
 * UserManagementConfigurationApi - object-oriented interface
 * @export
 * @class UserManagementConfigurationApi
 * @extends {BaseAPI}
 */
export class UserManagementConfigurationApi extends BaseAPI {
    /**
     * 
     * @summary 获取设置
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementConfigurationApi
     */
    public appUserManagementConfigurationGetSetting(X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserManagementConfigurationApiFp(this.configuration).appUserManagementConfigurationGetSetting(X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} input 
     * @param {} [X_XSRF_TOKEN] XSRF-TOKEN
     * @param {} [authorization] token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementConfigurationApi
     */
    public appUserManagementConfigurationSetSetting(input: UserManagementSettingDto, X_XSRF_TOKEN?: string, authorization?: string, options?: any) {
        return UserManagementConfigurationApiFp(this.configuration).appUserManagementConfigurationSetSetting(input, X_XSRF_TOKEN, authorization, options)(this.fetch, this.basePath);
    }

}

